<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Attack Surface Analysis - Part 1 - Application Update:
'A Novel Way to Bypass Executable Signature Checks with Electron'</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://parsiya.net/favicon.png rel=icon><meta name=description content><meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]"><meta name=author content="Parsia"><meta name=generator content="Hugo 0.97.3"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image:src content="https://parsiya.net/blog/2021-01-08-attack-surface-analysis-part-1-application-update-a-novel-way-to-bypass-executable-signature-checks-with-electron/13-cmd.png"><meta name=twitter:title content="Attack Surface Analysis - Part 1 - Application Update:
'A Novel Way to Bypass Executable Signature Checks with Electron'"><meta name=twitter:description content="A few months ago I found a way to subvert the update process of an Electron
application to get local privilege escalation. The application stores the
updater under a path where standard users have write access. But it also
checked if the executable was signed by the vendor. I managed to bypass the
signing using a backdoored Electron application."><meta name=twitter:domain content="parsiya.net"><meta name=twitter:creator content="@CryptoGangsta"></head><body><header role=banner><hgroup><h1><a href=https://parsiya.net/>Hackerman's Hacking Tutorials</a></h1><h2>The knowledge of anything, since all things have causes, is not acquired or
complete unless it is known by its causes. - Avicenna</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://parsiya.net/about/>» About Me!</option><option value=https://parsiya.net/cheatsheet/>» Cheat Sheet</option><option value=https://parsiya.io/>» My Clone</option><option value=https://github.com/parsiya/parsiya.net>» Source Repo</option><option value="https://queue.acm.org/detail.cfm?id=3197520">» Manual Work is a Bug</option><option value="https://www.google.com/search?q=andrew+ridgeley">» The Other Guy from Wham!</option></select></fieldset><ul class=main-navigation><li><a href=https://parsiya.net/about/ title="About Me!" target=_blank rel="noopener noreferrer">About Me!</a></li><li><a href=https://parsiya.net/cheatsheet/ title="Cheat Sheet" target=_blank rel="noopener noreferrer">Cheat Sheet</a></li><li><a href=https://parsiya.io/ title="My Clone" target=_blank rel="noopener noreferrer">My Clone</a></li><li><a href=https://github.com/parsiya/parsiya.net title="Source Repo" target=_blank rel="noopener noreferrer">Source Repo</a></li><li><a href="https://queue.acm.org/detail.cfm?id=3197520" title="Manual Work is a Bug" target=_blank rel="noopener noreferrer">Manual Work is a Bug</a></li><li><a href="https://www.google.com/search?q=andrew+ridgeley" title="The Other Guy from Wham!" target=_blank rel="noopener noreferrer">The Other Guy from Wham!</a></li></ul><ul class=subscription><a href=https://parsiya.net/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://parsiya.net/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Jan 8, 2021
- 11 minute read
- <a href=https://parsiya.net/blog/2021-01-08-attack-surface-analysis-part-1-application-update-a-novel-way-to-bypass-executable-signature-checks-with-electron/#disqus_thread>Comments</a>
- <a class=label href=https://parsiya.net/categories/electron/>Electron </a><a class=label href=https://parsiya.net/categories/attack-surface-analysis/>Attack Surface Analysis </a><a class=label href=https://parsiya.net/categories/bug-bounty/>Bug Bounty</a></p><h1 class=entry-title>Attack Surface Analysis - Part 1 - Application Update:
'A Novel Way to Bypass Executable Signature Checks with Electron'</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><a href=#light-attack-surface-analysis>Light Attack Surface Analysis</a><ul><li><a href=#what-is-privilege-escalation>What is Privilege Escalation?</a></li><li><a href=#from-update-to-privilege-escalation>From Update to Privilege Escalation</a><ul><li><a href=#spoofing-the-server>Spoofing The Server</a><ul><li><a href=#nintendo>Nintendo</a></li><li><a href=#backblaze-1---cve-2020-8289>Backblaze #1 - CVE-2020-8289</a></li><li><a href=#my-undisclosed-bug-1---updates-downloaded-over-http>My Undisclosed Bug #1 - Updates Downloaded Over HTTP</a></li></ul></li><li><a href=#swapping-the-update-file>Swapping The Update File</a><ul><li><a href=#backblaze-2---cve-2020-8290>Backblaze #2 - CVE-2020-8290</a></li><li><a href=#my-undisclosed-bug-2---installer-modified-the-program-directory-acl>My Undisclosed Bug #2 - Installer Modified The Program Directory ACL</a></li></ul></li></ul></li></ul></li><li><a href=#the-main-dish>The Main Dish</a><ul><li><a href=#named-pipe>Named Pipe</a></li><li><a href=#storage-path>Storage Path</a></li><li><a href=#signature-check>Signature Check</a></li></ul></li><li><a href=#using-electron-to-bypass-signature-checks>Using Electron to Bypass Signature Checks</a><ul><li><a href=#enter-electron>Enter Electron</a></li><li><a href=#recap>Recap</a></li><li><a href=#steps-to-reproduce>Steps to Reproduce</a></li></ul></li><li><a href=#what-did-we-learn-here-today>What Did We Learn Here Today?</a></li></ul></nav><p>A few months ago I found a way to subvert the update process of an Electron
application to get local privilege escalation. The application stores the
updater under a path where standard users have write access. But it also
checked if the executable was signed by the vendor. I managed to bypass the
signing using a backdoored Electron application.</p><h1 id=light-attack-surface-analysis>Light Attack Surface Analysis
<a class=header-link href=#light-attack-surface-analysis><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>After reading this section you should have a pretty good idea of how to attack
the update process of a Windows application. I have not been to find such a
section anywhere else ;).</p><h2 id=what-is-privilege-escalation>What is Privilege Escalation?
<a class=header-link href=#what-is-privilege-escalation><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>In short, you want to go from one of these levels to the next:</p><ol><li>Remote attacker</li><li>Local attacker running as a standard user</li><li>Local admin/SYSTEM</li></ol><p>Note: This is intentionally ignoring domain-connected machines and their attack
surfaces.</p><p>Moving from one level to the next is a privilege escalation.</p><blockquote><p>Code injection doesn't become a security hole until you have elevation of privilege.</p><footer><strong>Raymond Chen</strong>
<cite><a href="https://devblogs.microsoft.com/oldnewthing/20060508-22/?p=31283" title="https://devblogs.microsoft.com/oldnewthing/20060508-22/?p=31283">devblogs.microsoft.com/...</a></cite></footer></blockquote><h2 id=from-update-to-privilege-escalation>From Update to Privilege Escalation
<a class=header-link href=#from-update-to-privilege-escalation><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>The update process is usually a good way to gain local privilege. Application
updates on Windows usually need local admin (run as elevated) or SYSTEM (run via
a Windows service or scheduled task) access. They usually need to modify files
under the two <code>C:\Program Files</code> directories and these paths are not writable by
standard users.</p><h3 id=spoofing-the-server>Spoofing The Server
<a class=header-link href=#spoofing-the-server><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>If a remote attacker can spoof a server and taint the update binary then they
can go from a remote attacker to local or even SYSTEM.</p><p>Most often, this is not in scope for the few bounty programs with desktop
applications in scope. Also, TLS certificates do a good job of preventing such
attacks. But if you can mess with the certificate checks then you might have a
case.</p><h4 id=nintendo>Nintendo
<a class=header-link href=#nintendo><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h4><p>Let's skim through this report in Nintendo's bug bounty program.</p><ul><li><a href=https://hackerone.com/reports/894922 target=_blank rel="noreferrer noopener">https://hackerone.com/reports/894922</a></li></ul><p>The signature verification in 3DS is bypassed. This allows an attacker to
successfully sit between the console and the internet. For consoles this is
usually a feasible attack surface because the objective is to get root on them.</p><p>The next two reports take advantage of this attack vector and inject data into
the console's transmissions to achieve Remote Code Execution.</p><ul><li><a href=https://hackerone.com/reports/897606 target=_blank rel="noreferrer noopener">https://hackerone.com/reports/897606</a></li><li><a href=https://hackerone.com/reports/895769 target=_blank rel="noreferrer noopener">https://hackerone.com/reports/895769</a></li></ul><p>If we have such a bug in a desktop application we can spoof the server and taint
the update binary.</p><h4 id=backblaze-1---cve-2020-8289>Backblaze #1 - CVE-2020-8289
<a class=header-link href=#backblaze-1---cve-2020-8289><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h4><p>Another example is by <a href=https://twitter.com/JasonGeffner target=_blank rel="noreferrer noopener">Jason Geffner</a>. Jason is my former boss at
Electronic Arts and an all-around awesome guy.</p><ul><li><a href=https://github.com/geffner/CVE-2020-8289 target=_blank rel="noreferrer noopener">https://github.com/geffner/CVE-2020-8289</a></li></ul><p>The application disabled certificate checks if the URL had some specific strings
in it like <code>api/clientversion.xml</code>. The attacker could MitM the connection and
bypass the certificate check because the update URL had the string above. Then,
they could send their own tainted update binary to be executed as SYSTEM.</p><h4 id=my-undisclosed-bug-1---updates-downloaded-over-http>My Undisclosed Bug #1 - Updates Downloaded Over HTTP
<a class=header-link href=#my-undisclosed-bug-1---updates-downloaded-over-http><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h4><p>This is a bug I reported on HackerOne on April 24th, 2020 (around 9 months ago)
and is still open (no bounty awarded, either).</p><p>A Java application used <a href=https://github.com/threerings/getdown target=_blank rel="noreferrer noopener">getdown</a> to download its update over HTTP.
With HTTP, I could MitM the connection without any issues.</p><span class=caption-wrapper><img class=caption src=01-update-http.png title="Updates downloaded over HTTP" alt="Updates downloaded over HTTP">
<span class=caption-text>Updates downloaded over HTTP</span></span><p>Before downloading the actual files, <code>getdown</code> downloads a file named
<code>digest.txt</code>. This file has the hashes of the incoming update files. The hash in
this case was <code>MD5</code> (newer versions use <code>SHA-256</code>) but it did not really matter.
The digest file was also downloaded over HTTP and could be replaced, too.</p><p>I created a fake Python HTTP server to act as my spoofed server. I created my
own digest and a backdoored jar. The jar was a Swing application that only
displayed a JFrame. You can see the code at:</p><ul><li><a href=https://github.com/parsiya/EvilSwing target=_blank rel="noreferrer noopener">https://github.com/parsiya/EvilSwing</a></li></ul><h3 id=swapping-the-update-file>Swapping The Update File
<a class=header-link href=#swapping-the-update-file><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Sometimes, the update file is written to a path where a standard user has write
access and then executed (usually by a Windows service).</p><p>The usual suspects for such path are:</p><ul><li>Paths under <code>%ProgramData%</code> (usually <code>C:\ProgramData</code>).</li><li>Paths under <code>%APPDATA%</code></li><li>Predictable paths under <code>%TEMP%</code></li></ul><p>In these cases, we might be able to get LPE by overwriting the file with our
binary and then wait for the updater service to run it.</p><p>To avoid this, the applications check the signature of the binary (sometimes the
hash of the binary) or change the DACL of the path where it's stored to prevent
users from modifying it. The binary is executed only if the check passes.</p><p>As an attacker, you might be able to take advantage of a
<code>Time Of Check to Time of Use (TOCTOU)</code> vulnerability and exploit a race
condition to replace the binary after the check but before execution.</p><h4 id=backblaze-2---cve-2020-8290>Backblaze #2 - CVE-2020-8290
<a class=header-link href=#backblaze-2---cve-2020-8290><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h4><p>Here's another bug by Jason in Backblaze.</p><ul><li><a href=https://github.com/geffner/CVE-2020-8290 target=_blank rel="noreferrer noopener">https://github.com/geffner/CVE-2020-8290</a></li></ul><p>The updater which was a Windows service, created a directory to store the update
binary at <code>%ProgramData%\Backblaze\bzdata\bzupdates</code> if the path did not exist.
The DACL of the directory did not give standard users write access. But the
updater did not check if the directory was already created and would store the
updater there without changing its permissions. Hence, a local attacker could
create this directory and then replace the updater after download before
execution.</p><p>In a typical bug like this we are racing against the service that executes the
downloaded file. The way to win these races is often through OpLocks. This is
usually pretty easy with the <a href=https://github.com/googleprojectzero/symboliclink-testing-tools/blob/master/SetOpLock/SetOpLock_ReadMe.txt target=_blank rel="noreferrer noopener">SetOpLock</a> utility in the great
<a href=https://github.com/googleprojectzero/symboliclink-testing-tools target=_blank rel="noreferrer noopener">symboliclink-testing-tools</a> suite by
<a href=https://twitter.com/tiraniddo target=_blank rel="noreferrer noopener">James Forshaw</a>.</p><h4 id=my-undisclosed-bug-2---installer-modified-the-program-directory-acl>My Undisclosed Bug #2 - Installer Modified The Program Directory ACL
<a class=header-link href=#my-undisclosed-bug-2---installer-modified-the-program-directory-acl><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h4><p>This second bug was reported on April 23rd, 2020 (around 9 months ago) and is
still open with no bounty, again (see a pattern?).</p><p><strong>Update April 13th, 2021</strong>: This bug has finally been closed. The application
was retired and I got some money.</p><p><img src=15-bounty-bad-dacl.png alt></p><p>It's a bug in the same application as undisclosed bug #1. The installer changed
the DACL of the entire application directory under <code>C:\Program Files\app\</code>. The
new DACL gave write access to standard users.</p><span class=caption-wrapper><img class=caption src=02-acl.png title="Standard users have fullcontrol on the app directory" alt="Standard users have fullcontrol on the app directory">
<span class=caption-text>Standard users have fullcontrol on the app directory</span></span><p>I think the reason was seamless updates from userland without the need for a
Window service or UAC prompts. Usually, applications that want these kind of
updates are stored under <code>%APPDATA%</code> (e.g., VS Code).</p><p>I modified the uninstaller (which always ran elevated). A local attacker could
swap the binary with a backdoored executable and then wait for or convince an
admin to run the uninstaller elevated.</p><h1 id=the-main-dish>The Main Dish
<a class=header-link href=#the-main-dish><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Now, we have a pretty good idea of how to get LPE through automatic updates.
Let's talk about my last bug. I sat on the bug for six months because I was lazy
(see a pattern here? lol) and then reported it recently. It's still in review
and I doubt it will get disclosed.</p><h2 id=named-pipe>Named Pipe
<a class=header-link href=#named-pipe><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>The application uses a Windows service to do updates. The service talks to the
userland application using a <a href=https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes target=_blank rel="noreferrer noopener">named pipe</a>.</p><p>Named pipe is another great attack surface. I want to write a similar blog post
about them later but for now you can read these great series of posts by
<a href=https://twitter.com/HawesRT target=_blank rel="noreferrer noopener">Robert Hawes</a> on the Versprite blog:</p><ol><li><a href=https://versprite.com/blog/security-research/microsoft-windows-pipes-intro/ target=_blank rel="noreferrer noopener">Part I: The Fundamentals of Windows Named Pipes</a></li><li><a href=https://versprite.com/blog/security-research/vulnerable-named-pipe-application/ target=_blank rel="noreferrer noopener">Part II: Analysis of a Vulnerable Microsoft Windows Named Pipe Application</a></li><li><a href=https://versprite.com/blog/security-research/reverse-exploit-custom-windows-named-pipe-servers/ target=_blank rel="noreferrer noopener">Part 3: Reversing & Exploiting Custom Windows Named Pipe Servers</a></li><li><a href=https://versprite.com/blog/security-research/windows-named-pipes-static-analysis-exploitation/ target=_blank rel="noreferrer noopener">Part 4: Windows Named Pipes Part 4: Taking a Trip Down Static Analysis Lane</a></li></ol><p>This named pipe has a (fortunately) json-based protocol. The pipe is named
<code>george</code> (lol).</p><span class=caption-wrapper><img class=caption src=03-george.png title=George alt=George>
<span class=caption-text>George</span></span><p>Everyone can open a pipe and talk to the updater service. This is not a
vulnerability by itself. So don't go reporting pipe permissions nilly willy.</p><span class=caption-wrapper><img class=caption src=04-george-acl.png title="George likes everyone" alt="George likes everyone">
<span class=caption-text>George likes everyone</span></span><p>I used <code>github.com/microsoft/go-winio</code> to create a Go client. By sending
specific messages to the service I could check for an update, download it and
then run it. Unfortunately, I could only tell the service perform an action but
not how to do it. E.g., I could not specify the download URL, where to download
the file, or which file to execute.</p><h2 id=storage-path>Storage Path
<a class=header-link href=#storage-path><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>To observe the update process on Windows, your best tool is Process Monitor or
procmon. It's probably my favorite tool. You can run the updater process and see
where the file is downloaded and executed.</p><p>I did not need to use OpLocks because I could initiate the download and
execution events individually. In other words, I could tell the installer to
just download the update and nothing else. This gave me ample time to swap the
binary.</p><span class=caption-wrapper><img class=caption src=05-downloaded-file.png title="Downloaded file" alt="Downloaded file">
<span class=caption-text>Downloaded file</span></span><p>We can see the update is downloaded to
<code>C:\ProgramData\[redacted]\Updates\GUID.exe</code>. As we have seen before, by default,
standard users have write access here and this was not an exception.</p><pre tabindex=0><code>$ accesschk c:\ProgramData\[redacted]

c:\ProgramData\[redacted]\Updates
  RW BUILTIN\Users   &lt;---- WE HAVE RW ACCESS
  RW NT AUTHORITY\SYSTEM
  RW BUILTIN\Administrators
</code></pre><p>By now, you are thinking of pulling a "Jason's second bug" to overwrite the
downloaded file. This is what I did but the installer did not execute the file.</p><h2 id=signature-check>Signature Check
<a class=header-link href=#signature-check><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>Looking at procmon, I located the events where the file is accessed.</p><span class=caption-wrapper><img class=caption src=06-procmon-events.png title="File access event in procmon" alt="File access event in procmon">
<span class=caption-text>File access event in procmon</span></span><p>Procmon has a very useful feature where we can see the call stack of each event
(usually). All highlighted events above had a similar stack.</p><span class=caption-wrapper><img class=caption src=07-procmon-stack.png title="Call stack in Procmon" alt="Call stack in Procmon">
<span class=caption-text>Call stack in Procmon</span></span><p>Note the <code>WinVerifyTrust</code> calls. They are usually called to check the signature
of a file. At first, I thought I need to pass any signed file. There are some
<a href=https://github.com/LOLBAS-Project/LOLBAS#criteria target=_blank rel="noreferrer noopener">signed Windows binaries that can be used to run arbitrary commands</a>.
This is often used by red teams to evade detection.</p><p>My first try was swapping the file with a signed binary like <code>taskmgr.exe</code>. It
not work. Seemed like the updater was looking for a specific signature and not
just any valid one.</p><p>I hooked <code>WinVerifyTrust</code> in API Monitor and ran the original updater to see
the APIs arguments.</p><span class=caption-wrapper><img class=caption src=08-api-monitor.png title="WinVerifyTrust in API Monitor" alt="WinVerifyTrust in API Monitor">
<span class=caption-text>WinVerifyTrust in API Monitor</span></span><p>Looking at the <a href=https://docs.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust target=_blank rel="noreferrer noopener">WinVerifyTrust MSDN page</a> we can see that
the GUID (<code>00aac56b-cd44-11d0-8cc2-00c04fc295ee</code>) is for
<code>WINTRUST_ACTION_GENERIC_VERIFY_V2</code> which is the typical authenticode check. In
other words, it's checking the certificate. For the original updater, the return
value of our calls is <code>S_OK</code> or <code>0</code> which means it has a valid signature.</p><p>I dropped the executable in IDA and searched for <code>WinVerifyTrust</code>. After some
analysis, I landed at the following location. There are two calls to
<code>WinVerifyTrust</code> around a call to <code>sub_100550</code>. After more dynamic analysis, I
discovered the subroutine checks the Common Name (CN) of the certificate against
<code>vendor</code>. This means the updater is looking for a binary file signed by the
vendor. You had already guessed it by now.</p><span class=caption-wrapper><img class=caption src=09-check-in-ida.png title="Signatute checks in IDA" alt="Signatute checks in IDA">
<span class=caption-text>Signatute checks in IDA</span></span><p>It does three checks on each file:</p><ol><li>Signature check.</li><li>Check if CN is <code>vendor</code>.</li><li>Signature check (again).</li></ol><p>Why are there two authenticode checks? Most likely, to prevent TOCTOU race
conditions.</p><h1 id=using-electron-to-bypass-signature-checks>Using Electron to Bypass Signature Checks
<a class=header-link href=#using-electron-to-bypass-signature-checks><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>At this point, I was back to square one. I needed a binary that was signed by
the vendor and allowed me to run arbitrary code. Binary modification does not
work because it invalidates the signature.</p><p>That's when I realized I already have such a binary and it can run arbitrary
code. The original app was an Electron app and the executable was signed by the
<code>vendor</code>.</p><h2 id=enter-electron>Enter Electron
<a class=header-link href=#enter-electron><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>A typical Electron app on Windows comes with a bunch of executables. I cannot
use the actual app so let's look at another Electron app named Discord. Almost
everything in the app directory is part of the Electron framework and not
application code.</p><span class=caption-wrapper><img class=caption src=10-discord-files.png title="Discord's application directory" alt="Discord's application directory">
<span class=caption-text>Discord's application directory</span></span><p>The executable is <code>Discord.exe</code> which is signed by <code>Discord Inc.</code>. In my target
application, it was signed by <code>vendor</code>.</p><span class=caption-wrapper><img class=caption src=11-discord-sig.png title="Discord executable's signature" alt="Discord executable's signature">
<span class=caption-text>Discord executable's signature</span></span><p>The actual code of the Electron application is usually in <code>resources\app.asar</code>.
The asar container is unsigned. It's just a bunch of data and the format does
not support signing. TWe can modify it and the signed binary <code>Discord.exe</code> will
run our modified code.</p><p>For my proof of concept, I created a backdoored Electron application:</p><ul><li><a href=https://github.com/parsiya/evil-electron/ target=_blank rel="noreferrer noopener">https://github.com/parsiya/evil-electron/</a></li></ul><p>All it does is spawn a command prompt using <code>preload.js</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#586e75>// Spawn a command prompt.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>require(<span style=color:#2aa198>&#39;child_process&#39;</span>).exec(<span style=color:#2aa198>&#39;start cmd.exe&#39;</span>);
</span></span></code></pre></div><p>The built <code>app.asar</code> file is at
<a href=https://github.com/parsiya/evil-electron/tree/master/release target=_blank rel="noreferrer noopener">https://github.com/parsiya/evil-electron/tree/master/release</a>.</p><span class=caption-wrapper><img class=caption src=12-backdoored-app.png title="It took me a while to figure out the payload" alt="It took me a while to figure out the payload">
<span class=caption-text>It took me a while to figure out the payload</span></span><p>The idea of backdooring an Electron app is not really new. After writing this
blog, I discovered a blog post by <a href=https://twitter.com/sadreck target=_blank rel="noreferrer noopener">Pavel Tsakalidis</a> from January
2019 (almost two years ago):</p><ul><li><a href=https://www.contextis.com/en/blog/basic-electron-framework-exploitation target=_blank rel="noreferrer noopener">Basic Electron Framework Exploitation</a></li></ul><p>The title of the web page says <code>How To Backdoor Any Electron Application</code> which
appears to have been the original title of the blog.</p><p>Most of the blog talks about backdooring the <code>resources\electron.asar</code> file
which is not present in many modern Electron applications anymore. But the
concept is sound. We can modify asar files and backdoor them. This blog, while
nice, is more of a red team persistence trick and not signature evasion like
what we want to do.</p><h2 id=recap>Recap
<a class=header-link href=#recap><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><ol><li>The application's updater service downloads the update and stores it in
<code>C:\ProgramData\[redacted]\GUID.exe</code>.</li><li>Standard users have write access to this path.</li><li>The updater service checks the signature of the file before executing it.</li><li>The file should have a valid signature and it must be signed by <code>vendor</code>.</li><li>The bundled Electron app is signed by <code>vendor</code> and we can backdoor it.</li></ol><h2 id=steps-to-reproduce>Steps to Reproduce
<a class=header-link href=#steps-to-reproduce><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><ol><li>Tell the service to download the update (via the named pipe).</li><li>Copy everything inside <code>C:\Program Files (x86)\vendor\electron-app\</code> to
<code>C:\ProgramData\[redacted]\Updates</code> (where the update is downloaded).</li><li>Delete the downloaded installer but copy its filename (<code>GUID.exe</code>).</li><li>Rename <code>electron-app.exe</code> to the name of the downloaded installer (<code>GUID.exe</code>).</li><li>Replace the <code>resources\app.asar</code> file in the destination with my own
backdoored file.</li><li>Tell the Windows service to run the installer.</li><li>Command prompt spawned as SYSTEM.</li></ol><span class=caption-wrapper><img class=caption src=13-cmd.png title="cmd as SYSTEM" alt="cmd as SYSTEM">
<span class=caption-text>cmd as SYSTEM</span></span><p>I got 200 USD for the bug. Financially, not worth the time spent, but I learned
a new trick. Although, it would have been completely different if I were living
in a cheap country with low taxes.</p><span class=caption-wrapper><img class=caption src=14-bounty.png title=Bounty alt=Bounty>
<span class=caption-text>Bounty</span></span><h1 id=what-did-we-learn-here-today>What Did We Learn Here Today?
<a class=header-link href=#what-did-we-learn-here-today><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><ol><li>Attack surface analysis of application update mechanisms on Windows.</li><li>How to take advantage of the above.</li><li>Reviewed a bunch of bugs to learn a variety of exploitation techniques.</li><li>Learned a 'novel' way of bypassing signature checks using Electron
applications.</li></ol></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Parsia</span></span>
<time>Jan 8, 2021</time></span></p><p class=meta><a class="basic-alignment left" href=https://parsiya.net/blog/2021-01-01-the-15000-playstation-bounty/ title="The $15000 PlayStation Bounty">The $15000 PlayStation Bounty</a>
<a class="basic-alignment right" href=https://parsiya.net/blog/2021-01-17-some-sans-holiday-hack-2020-solutions/ title="Some SANS Holiday Hack 2020 Solutions">Some SANS Holiday Hack 2020 Solutions</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//parsiya.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I?</h1><p><p>I am Parsia, a senior security engineer at <a href=https://www.ea.com/security target=_blank rel="noreferrer noopener">Electronic Arts</a>.</p><p>I write about application security, reverse engineering,
Go, cryptography, and (obviously) videogames.</p><p>Click on <a href=/about/>About Me!</a> to know more.</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/parsiya/ title=https://github.com/parsiya/><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://twitter.com/cryptogangsta/ title=https://twitter.com/cryptogangsta/><i class="fa fa-twitter fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://keybase.io/parsiya/ title=https://keybase.io/parsiya/><i class="fa fa-keybase fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/parsiya title=https://www.linkedin.com/in/parsiya><i class="fa fa-linkedin fa-3x"></i></a></li></ul><section class=odd><h1>Collections</h1><li><a href=https://parsiya.net/categories/thick-client-proxying/ title="Thick Client Proxying">Thick Client Proxying</a></li><li><a href=https://parsiya.net/categories/writeup/ title=CTFs/Writeups>CTFs/Writeups</a></li><li><a href=https://parsiya.net/categories/attack-surface-analysis/ title="Attack Surface Analysis">Attack Surface Analysis</a></li><li><a href=https://parsiya.net/categories/bug-bounty/ title="Bug Bounty">Bug Bounty</a></li><li><a href=https://parsiya.net/categories/go/ title=Go/Golang>Go/Golang</a></li><li><a href=https://parsiya.net/categories/blockchain/ title=Blockchain>Blockchain</a></li><li><a href=https://parsiya.net/categories/burp-extension/ title="Burp Extension Development">Burp Extension Development</a></li><li><a href=https://parsiya.net/categories/automation/ title=Automation>Automation</a></li><li><a href=https://parsiya.net/categories/reverse-engineering/ title="Reverse Engineering">Reverse Engineering</a></li><li><a href=https://parsiya.net/categories/crypto/ title=Crypto(graphy)>Crypto(graphy)</a></li><li><a href=https://parsiya.net/categories/winappdbg/ title=WinAppDbg>WinAppDbg</a></li><li><a href=https://awsome.pw title="AWSome.pw - S3 bucket squatting - my very legit branded vulnerability">AWSome.pw - S3 bucket squatting - my very legit branded vulnerability</a></li></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2022 Parsia - <a href=https://parsiya.net/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>