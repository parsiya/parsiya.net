<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1">
<link href=/css/fonts.css rel=stylesheet type=text/css>
<title>Windows Filetime Timestamps and Byte Wrangling with Go</title><link rel=stylesheet href=/css/hugo-octopress.css>
<link rel=stylesheet href=/css/fork-awesome.min.css>
<link href=https://parsiya.net/favicon.png rel=icon>
<meta name=description content>
<meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]">
<meta name=author content="Parsia">
<meta name=generator content="Hugo 0.93.0">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image:src content="https://parsiya.net/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/filetime.png">
<meta name=twitter:title content="Windows Filetime Timestamps and Byte Wrangling with Go">
<meta name=twitter:description content="For a side project, I have to parse timestamps in a file. These timestamps are in the Windows Filetime format. This post documents what I have learned about them and how they can be converted to a Golang time.Time and then converted to any desirable format after that.
We will start by looking at endian-ness and use a real-world example to practice our newly acquired knowledge.
TL;DR: To convert a Windows Filetime to Go's time.Time:

Read 8 bytes in LittleEndian from the file.
Create a syscall.Filetime.

Assign the first 4 bytes to LowDateTime field and the other four to HighDateTime.


Convert the resulting Filetime to nanoseconds with Filetime.Nanoseconds().
Convert the resulting value to time.Time.

The code is at:

https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling
">
<meta name=twitter:domain content="parsiya.net">
<meta name=twitter:creator content="@CryptoGangsta">
</head><body>
<header role=banner>
<hgroup>
<h1><a href=https://parsiya.net/>Hackerman's Hacking Tutorials</a></h1><h2>The knowledge of anything, since all things have causes, is not acquired or
complete unless it is known by its causes. - Avicenna</h2></hgroup></header><nav role=navigation>
<fieldset class=mobile-nav>
<select onchange="location=this.value"><option value>Navigate…</option><option value=https://parsiya.net/about/>» About Me!</option><option value=https://parsiya.net/cheatsheet/>» Cheat Sheet</option><option value=https://parsiya.io/>» My Clone</option><option value=https://github.com/parsiya/parsiya.net>» Source Repo</option><option value="https://queue.acm.org/detail.cfm?id=3197520">» Manual Work is a Bug</option><option value="https://www.google.com/search?q=andrew+ridgeley">» The Other Guy from Wham!</option></select>
</fieldset><ul class=main-navigation>
<li><a href=https://parsiya.net/about/ title="About Me!" target=_blank rel="noopener noreferrer">About Me!</a></li><li><a href=https://parsiya.net/cheatsheet/ title="Cheat Sheet" target=_blank rel="noopener noreferrer">Cheat Sheet</a></li><li><a href=https://parsiya.io/ title="My Clone" target=_blank rel="noopener noreferrer">My Clone</a></li><li><a href=https://github.com/parsiya/parsiya.net title="Source Repo" target=_blank rel="noopener noreferrer">Source Repo</a></li><li><a href="https://queue.acm.org/detail.cfm?id=3197520" title="Manual Work is a Bug" target=_blank rel="noopener noreferrer">Manual Work is a Bug</a></li><li><a href="https://www.google.com/search?q=andrew+ridgeley" title="The Other Guy from Wham!" target=_blank rel="noopener noreferrer">The Other Guy from Wham!</a></li></ul><ul class=subscription>
<a href=https://parsiya.net/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a>
</ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer">
<fieldset role=search>
<input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://parsiya.net/>
</fieldset></form></nav><div id=main>
<div id=content>
<div>
<article class=hentry role=article>
<header>
<p class=meta>Nov 1, 2018
- 7 minute read
- <a href=https://parsiya.net/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/#disqus_thread>Comments</a>
- <a class=label href=https://parsiya.net/categories/go/>Go </a>
</p><h1 class=entry-title>
Windows Filetime Timestamps and Byte Wrangling with Go
</h1></header><div class=entry-content>
<nav id=TableOfContents>
<ul>
<li><a href=#endianness-with-useful-examples>Endianness with Useful Examples</a></li><li><a href=#binaryread>binary.Read</a>
<ul>
<li><a href=#reading-byte-or-byte>Reading []byte or [...]byte</a></li></ul></li><li><a href=#mild-lnk-reverse-engineering>Mild lnk Reverse Engineering</a></li><li><a href=#filetime>Filetime</a></li></ul></nav><p>For a side project, I have to parse timestamps in a file. These timestamps are in the Windows Filetime format. This post documents what I have learned about them and how they can be converted to a Golang <a href=https://golang.org/pkg/time/#Time target=_blank rel="noreferrer noopener">time.Time</a> and then converted to any desirable format after that.</p><p>We will start by looking at endian-ness and use a real-world example to practice our newly acquired knowledge.</p><p><strong>TL;DR: To convert a Windows Filetime to Go's time.Time:</strong></p><ol>
<li>Read 8 bytes in LittleEndian from the file.</li><li>Create a <code>syscall.Filetime</code>.
<ul>
<li>Assign the first 4 bytes to <code>LowDateTime</code> field and the other four to <code>HighDateTime</code>.</li></ul></li><li>Convert the resulting Filetime to nanoseconds with <a href=https://godoc.org/golang.org/x/sys/windows#Filetime.Nanoseconds target=_blank rel="noreferrer noopener">Filetime.Nanoseconds()</a>.</li><li>Convert the resulting value to <a href=https://golang.org/pkg/time/#Time target=_blank rel="noreferrer noopener">time.Time</a>.</li></ol><p>The code is at:</p><ul>
<li><a href=https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling target=_blank rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling</a></li></ul><h1 id=endianness-with-useful-examples>Endianness with Useful Examples
<a class=header-link href=#endianness-with-useful-examples><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a>
</h1><p>You probably already know about endianness. It's how the bytes are ordered. Literals are almost always written in big-endian like <code>0xAABBCCDD</code>. In math, numbers are stored and read in big-endian (e.g. <code>1337</code>). In little-endian, they are stored with LSB being first. So the result is <code>DD CC BB AA</code> on disk. When reading from disk, we read four bytes and then reverse it.</p><p>Network protocols usually deal with the big-endian order. When sending data, we read and send the first byte first. When we look at the data on the wire, LSB is seen first and then the rest.</p><p>What infuriates me are the examples. Every tutorial uses only four bytes (like I did above). But what if we want to read a <code>dword</code> (a double-word is usually 8 bytes) from disk (little-endian). Do we read all bytes and reverse them? What about two <code>word</code>s?</p><p>Let's try to read these 8 bytes into a <code>uint64</code> <code>D0 E9 EE F2 15 15 C9 01</code>. Run <code>01-littleendian-uint64.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/hex&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Simulate 8 bytes BigEndian.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    cr, _ <span style=color:#719e07>:=</span> hex.<span style=color:#268bd2>DecodeString</span>(strings.<span style=color:#268bd2>Replace</span>(<span style=color:#2aa198>&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style=color:#2aa198>&#34; &#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Read them into a uint64
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    u64 <span style=color:#719e07>:=</span> binary.LittleEndian.<span style=color:#268bd2>Uint64</span>(cr)
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Print the bytes
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;%016x&#34;</span>, u64)
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 01c91515f2eee9d0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>Using <code>BigEndian</code> would give us the order in the original string.</p><h1 id=binaryread>binary.Read
<a class=header-link href=#binaryread><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a>
</h1><p>When reading from a file, we are mostly dealing with an <code>io.Reader</code>. They are great for file parsing. We can read as we go and do not have to worry about keeping track of the offset. Another advantage is using <a href=https://golang.org/pkg/encoding/binary/#Read target=_blank rel="noreferrer noopener">binary.Read</a>. We can pass a data structure to it (as a pointer), it will detect the size and try to fill it. Run <code>02-littleendian-uint64-reader.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/hex&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Simulate 8 bytes BigEndian.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	cr, _ <span style=color:#719e07>:=</span> hex.<span style=color:#268bd2>DecodeString</span>(strings.<span style=color:#268bd2>Replace</span>(<span style=color:#2aa198>&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style=color:#2aa198>&#34; &#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Create an io.Reader from []byte for simulation.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	buf <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>NewReader</span>(cr)
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> u64 <span style=color:#dc322f>uint64</span>
</span></span><span style=display:flex><span>	err <span style=color:#719e07>:=</span> binary.<span style=color:#268bd2>Read</span>(buf, binary.LittleEndian, <span style=color:#719e07>&amp;</span>u64)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;%016x&#34;</span>, u64)
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 01c91515f2eee9d0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>But what if we want to read two little-endian <code>uint32</code>s? That is similar. Run <code>03-littlendian-two-uint32.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/hex&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Simulate 8 bytes BigEndian.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	cr, _ <span style=color:#719e07>:=</span> hex.<span style=color:#268bd2>DecodeString</span>(strings.<span style=color:#268bd2>Replace</span>(<span style=color:#2aa198>&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style=color:#2aa198>&#34; &#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Create an io.Reader from []byte.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	buf <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>NewReader</span>(cr)
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> u32One, u32Two <span style=color:#dc322f>uint32</span>
</span></span><span style=display:flex><span>	err <span style=color:#719e07>:=</span> binary.<span style=color:#268bd2>Read</span>(buf, binary.LittleEndian, <span style=color:#719e07>&amp;</span>u32One)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	err = binary.<span style=color:#268bd2>Read</span>(buf, binary.LittleEndian, <span style=color:#719e07>&amp;</span>u32Two)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;u32-1: %08x\n&#34;</span>, u32One) <span style=color:#586e75>// u32-1: f2eee9d0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;u32-1: %08x\n&#34;</span>, u32Two) <span style=color:#586e75>// u32-1: 01c91515
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>Both approaches pretty much give us the same results.</p><h2 id=reading-byte-or-byte>Reading []byte or [...]byte
<a class=header-link href=#reading-byte-or-byte><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a>
</h2><p>We can also fill <code>[]byte</code> from <code>io.Reader</code> with <code>binary.Read</code>. In these cases, we need to create a <code>[]byte</code> of a specific length and read those many bytes. Let's get the entire 72 bytes from the original example <code>04-read-byte-slice.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/hex&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	cr, _ <span style=color:#719e07>:=</span> hex.<span style=color:#268bd2>DecodeString</span>(<span style=color:#2aa198>&#34;4C0000000114020000000000C000000000000046&#34;</span> <span style=color:#719e07>+</span>
</span></span><span style=display:flex><span>		<span style=color:#2aa198>&#34;9B00080020000000D0E9EEF21515C901D0E9EEF21515C901D0E9EEF21515C90100&#34;</span> <span style=color:#719e07>+</span>
</span></span><span style=display:flex><span>		<span style=color:#2aa198>&#34;0000000000000001000000000000000000000000000000&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Create an io.Reader from []byte.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	buf <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>NewReader</span>(cr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	headerLittleEndian <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>byte</span>, <span style=color:#2aa198>72</span>)
</span></span><span style=display:flex><span>	err <span style=color:#719e07>:=</span> binary.<span style=color:#268bd2>Read</span>(buf, binary.LittleEndian, <span style=color:#719e07>&amp;</span>headerLittleEndian)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;headerLittleEndian&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(hex.<span style=color:#268bd2>Dump</span>(headerLittleEndian))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Reset the reader.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	buf = bytes.<span style=color:#268bd2>NewReader</span>(cr)
</span></span><span style=display:flex><span>	headerBigEndian <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>byte</span>, <span style=color:#2aa198>72</span>)
</span></span><span style=display:flex><span>	err = binary.<span style=color:#268bd2>Read</span>(buf, binary.BigEndian, <span style=color:#719e07>&amp;</span>headerBigEndian)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;headerBigEndian&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(hex.<span style=color:#268bd2>Dump</span>(headerBigEndian))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the result is the same in both cases.</p><pre tabindex=0><code>headerLittleEndian
00000000  4c 00 00 00 01 14 02 00  00 00 00 00 c0 00 00 00  |L...............|
00000010  00 00 00 46 9b 00 08 00  20 00 00 00 d0 e9 ee f2  |...F.... .......|
00000020  15 15 c9 01 d0 e9 ee f2  15 15 c9 01 d0 e9 ee f2  |................|
00000030  15 15 c9 01 00 00 00 00  00 00 00 00 01 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00                           |........|

headerBigEndian
00000000  4c 00 00 00 01 14 02 00  00 00 00 00 c0 00 00 00  |L...............|
00000010  00 00 00 46 9b 00 08 00  20 00 00 00 d0 e9 ee f2  |...F.... .......|
00000020  15 15 c9 01 d0 e9 ee f2  15 15 c9 01 d0 e9 ee f2  |................|
00000030  15 15 c9 01 00 00 00 00  00 00 00 00 01 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00                           |........|
</code></pre><p><strong>If you are reading []byte or byte arrays, the order doesn't really matter. You get the original order of bytes.</strong></p><p>That was quite the detour, but now we know how ro read bytes in Go.</p><h1 id=mild-lnk-reverse-engineering>Mild lnk Reverse Engineering
<a class=header-link href=#mild-lnk-reverse-engineering><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a>
</h1><p>We are going to use a Windows Shortcut or <code>lnk</code> file for practice. Luckily, MSDN has an <a href=https://msdn.microsoft.com/en-us/library/dd871375.aspx target=_blank rel="noreferrer noopener">example</a>. We are going to only need the file header or the first <code>72</code> (or <code>0x4C</code>) bytes. Here's a hexdump:</p><pre tabindex=0><code>00000000  4C 00 00 00 01 14 02 00 00 00 00 00 C0 00 00 00  |L...........À...|
00000010  00 00 00 46 9B 00 08 00 20 00 00 00 D0 E9 EE F2  |...F.... ...Ðéîò|
00000020  15 15 C9 01 D0 E9 EE F2 15 15 C9 01 D0 E9 EE F2  |..É.Ðéîò..É.Ðéîò|
00000030  15 15 C9 01 00 00 00 00 00 00 00 00 01 00 00 00  |..É.............|
00000040  00 00 00 00 00 00 00 00 00 00 00 00              |............|
</code></pre><p>MSDN has the <a href=https://msdn.microsoft.com/en-us/library/dd871305.aspx target=_blank rel="noreferrer noopener">MS-SHLLINK</a>. Open the revision 5.0 (latest at the time of writing) file to see the format. The example page also contains a break down of all fields.</p><p>There are three timestamps. Each one is eight bytes and is stored in little-endian order:</p><ul>
<li><code>CreationTime</code> at offset <code>0x1C</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li><li><code>AccessTime</code> at offset <code>0x24</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li><li><code>WriteTime</code> at offset <code>0x2C</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li></ul><h1 id=filetime>Filetime
<a class=header-link href=#filetime><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a>
</h1><p>According to the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284%28v=vs.85%29.aspx" target=_blank rel="noreferrer noopener">FILETIME structure</a>, it's "a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC)." Oh boy!</p><p>We need to convert it to to Unix nano, which is the number of nanoseconds elapsed since January 1, 1970, 00:00:00 (UTC). To convert these, we can either do things by hand (multiply the Windows timestamp by 100 and then subtract the number of nanoseconds between epoch times) or just let someone else do the calculation for us. Fortunately, I found a type in Go in two places that point to one location:</p><ul>
<li><a href="https://golang.org/pkg/syscall/?GOOS=windows&GOARCH=amd64#Filetime" target=_blank rel="noreferrer noopener">syscall.Filetime</a></li><li><a href=https://godoc.org/golang.org/x/sys/windows#Filetime target=_blank rel="noreferrer noopener">golang.org/x/sys/windows.Filetime</a></li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>type</span> Filetime <span style=color:#268bd2>struct</span> {
</span></span><span style=display:flex><span>	LowDateTime  <span style=color:#dc322f>uint32</span>
</span></span><span style=display:flex><span>	HighDateTime <span style=color:#dc322f>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To convert a Windows Filetime to Go's time.Time:</p><ol>
<li>Read 8 bytes in LittleEndian from the file.</li><li>Create a <code>syscall.Filetime</code>.
<ol>
<li>Assign the first 4 bytes to <code>LowDateTime</code> field and the other to <code>HighDateTime</code>.</li></ol></li><li>Convert the resulting Filetime to nanoseconds with <a href=https://godoc.org/golang.org/x/sys/windows#Filetime.Nanoseconds target=_blank rel="noreferrer noopener">Filetime.Nanoseconds()</a>.</li><li>Convert the resulting value to time.Time.</li></ol><p>Let's create a function:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// toTime converts an 8-byte Windows Filetime to time.Time.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>toTime</span>(t [<span style=color:#2aa198>8</span>]<span style=color:#dc322f>byte</span>) time.Time {
</span></span><span style=display:flex><span>	ft <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>syscall.Filetime{
</span></span><span style=display:flex><span>		LowDateTime:  binary.LittleEndian.<span style=color:#268bd2>Uint32</span>(t[:<span style=color:#2aa198>4</span>]),
</span></span><span style=display:flex><span>		HighDateTime: binary.LittleEndian.<span style=color:#268bd2>Uint32</span>(t[<span style=color:#2aa198>4</span>:]),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> time.<span style=color:#268bd2>Unix</span>(<span style=color:#2aa198>0</span>, ft.<span style=color:#268bd2>Nanoseconds</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We are passing an 8-byte array (we could modify it to be a <code>[]byte</code> but that would add range checks, error handling, and panics). The byte array is most likely big-endian (because we read it directly from the reader), so we are reading each <code>uint32</code> in little-endian order. Then we populate <code>Filetime</code> and finally convert it to <code>time.Time</code>. Now we can do whatever we want with this.</p><p>Let's run this function on our timestamp (all three are the same in the MSDN example). Run <code>05-parse-timestamp.go</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;encoding/hex&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;syscall&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	cr, _ <span style=color:#719e07>:=</span> hex.<span style=color:#268bd2>DecodeString</span>(strings.<span style=color:#268bd2>Replace</span>(<span style=color:#2aa198>&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style=color:#2aa198>&#34; &#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>))
</span></span><span style=display:flex><span>	buf <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>NewReader</span>(cr)
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> timestamp [<span style=color:#2aa198>8</span>]<span style=color:#dc322f>byte</span>
</span></span><span style=display:flex><span>	err <span style=color:#719e07>:=</span> binary.<span style=color:#268bd2>Read</span>(buf, binary.LittleEndian, <span style=color:#719e07>&amp;</span>timestamp)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	t <span style=color:#719e07>:=</span> <span style=color:#268bd2>toTime</span>(timestamp)
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(t)
</span></span><span style=display:flex><span>	fmt.<span style=color:#268bd2>Println</span>(t.<span style=color:#268bd2>UTC</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// toTime converts an 8-byte Windows Filetime to time.Time.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>toTime</span>(t [<span style=color:#2aa198>8</span>]<span style=color:#dc322f>byte</span>) time.Time {
</span></span><span style=display:flex><span>	ft <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>syscall.Filetime{
</span></span><span style=display:flex><span>		LowDateTime:  binary.LittleEndian.<span style=color:#268bd2>Uint32</span>(t[:<span style=color:#2aa198>4</span>]),
</span></span><span style=display:flex><span>		HighDateTime: binary.LittleEndian.<span style=color:#268bd2>Uint32</span>(t[<span style=color:#2aa198>4</span>:]),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> time.<span style=color:#268bd2>Unix</span>(<span style=color:#2aa198>0</span>, ft.<span style=color:#268bd2>Nanoseconds</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which is the same as the MSDN example:</p><pre tabindex=0><code>2008-09-12 16:27:17.101 -0400 EDT
2008-09-12 20:27:17.101 +0000 UTC
</code></pre></div><footer>
<p class=meta>
<span class="byline author vcard">Posted by <span class=fn>Parsia</span></span>
<time>Nov 1, 2018</time>
<span class=categories>
Tags:
<a class=category href=https://parsiya.net/tags/filetime>filetime</a>
</span>
</p><p class=meta>
<a class="basic-alignment left" href=https://parsiya.net/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/ title="Blackfriday's Parser and Generating graphs with gographviz">Blackfriday's Parser and Generating graphs with gographviz</a>
<a class="basic-alignment right" href=https://parsiya.net/blog/2018-11-10-filepath.ext-notes/ title="filepath.Ext Notes">filepath.Ext Notes</a>
</p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//parsiya.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</footer></article></div><aside class="sidebar thirds">
<section class="first odd">
<h1>Who am I?</h1><p>
<p>I am Parsia, a senior security engineer at <a href=https://www.ea.com/security target=_blank rel="noreferrer noopener">Electronic Arts</a>.</p><p>I write about application security, reverse engineering,
Go, cryptography, and (obviously) videogames.</p><p>Click on <a href=/about/>About Me!</a> to know more.</p></p></section><ul class=sidebar-nav>
<li class=sidebar-nav-item>
<a target=_blank rel="noopener noreferrer" href=https://github.com/parsiya/ title=https://github.com/parsiya/><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://twitter.com/cryptogangsta/ title=https://twitter.com/cryptogangsta/><i class="fa fa-twitter fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://keybase.io/parsiya/ title=https://keybase.io/parsiya/><i class="fa fa-keybase fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/parsiya title=https://www.linkedin.com/in/parsiya><i class="fa fa-linkedin fa-3x"></i></a>
</li></ul><section class=odd>
<h1>Collections</h1><li>
<a href=https://parsiya.net/categories/thick-client-proxying/ title="Thick Client Proxying">Thick Client Proxying</a>
</li><li>
<a href=https://parsiya.net/categories/writeup/ title=CTFs/Writeups>CTFs/Writeups</a>
</li><li>
<a href=https://parsiya.net/categories/attack-surface-analysis/ title="Attack Surface Analysis">Attack Surface Analysis</a>
</li><li>
<a href=https://parsiya.net/categories/bug-bounty/ title="Bug Bounty">Bug Bounty</a>
</li><li>
<a href=https://parsiya.net/categories/go/ title=Go/Golang>Go/Golang</a>
</li><li>
<a href=https://parsiya.net/categories/blockchain/ title=Blockchain>Blockchain</a>
</li><li>
<a href=https://parsiya.net/categories/burp-extension/ title="Burp Extension Development">Burp Extension Development</a>
</li><li>
<a href=https://parsiya.net/categories/automation/ title=Automation>Automation</a>
</li><li>
<a href=https://parsiya.net/categories/reverse-engineering/ title="Reverse Engineering">Reverse Engineering</a>
</li><li>
<a href=https://parsiya.net/categories/crypto/ title=Crypto(graphy)>Crypto(graphy)</a>
</li><li>
<a href=https://parsiya.net/categories/winappdbg/ title=WinAppDbg>WinAppDbg</a>
</li><li>
<a href=https://awsome.pw title="AWSome.pw - S3 bucket squatting - my very legit branded vulnerability">AWSome.pw - S3 bucket squatting - my very legit branded vulnerability</a>
</li></section></aside></div></div><footer role=contentinfo>
<p>Copyright &copy; 2022 Parsia - <a href=https://parsiya.net/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.
</p></footer></body></html>