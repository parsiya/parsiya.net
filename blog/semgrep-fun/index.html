<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>A Few Fun Semgrep Experiments</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://parsiya.net/favicon.png rel=icon><meta name=description content><meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]"><meta name=author content="Parsia"><meta name=generator content="Hugo 0.122.0"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image:src content="https://parsiya.net/blog/semgrep-fun/05.png"><meta name=twitter:title content="A Few Fun Semgrep Experiments"><meta name=twitter:description content="I want to use Semgrep as a light code intelligence tool with a few experiments.
I will write custom rules to extract info from code and then process the
results.
The type of these experiments is inspired by Martin Jambon who is
actually a core Semgrep developer. These are supposed to be self-contained but
short experiments. You can see his at https://github.com/mjambon/dev-random."><meta name=twitter:domain content="parsiya.net"><meta name=twitter:creator content="@CryptoGangsta"></head><body><header role=banner><hgroup><h1><a href=https://parsiya.net/>Hackerman's Hacking Tutorials</a></h1><h2>The knowledge of anything, since all things have causes, is not acquired or
complete unless it is known by its causes. - Avicenna</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://parsiya.net/about/>» About Me!</option><option value=https://parsiya.net/cheatsheet/>» Cheat Sheet</option><option value=https://parsiya.io/>» My Clone</option><option value=https://github.com/parsiya/parsiya.net>» Source Repo</option><option value="https://queue.acm.org/detail.cfm?id=3197520">» Manual Work is a Bug</option><option value="https://www.google.com/search?q=andrew+ridgeley">» The Other Guy from Wham!</option></select></fieldset><ul class=main-navigation><li><a href=https://parsiya.net/about/ title="About Me!" target=_blank rel="noopener noreferrer">About Me!</a></li><li><a href=https://parsiya.net/cheatsheet/ title="Cheat Sheet" target=_blank rel="noopener noreferrer">Cheat Sheet</a></li><li><a href=https://parsiya.io/ title="My Clone" target=_blank rel="noopener noreferrer">My Clone</a></li><li><a href=https://github.com/parsiya/parsiya.net title="Source Repo" target=_blank rel="noopener noreferrer">Source Repo</a></li><li><a href="https://queue.acm.org/detail.cfm?id=3197520" title="Manual Work is a Bug" target=_blank rel="noopener noreferrer">Manual Work is a Bug</a></li><li><a href="https://www.google.com/search?q=andrew+ridgeley" title="The Other Guy from Wham!" target=_blank rel="noopener noreferrer">The Other Guy from Wham!</a></li></ul><ul class=subscription><a href=https://parsiya.net/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://parsiya.net/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Jan 21, 2024
- 18 minute read
- <a href=https://parsiya.net/blog/semgrep-fun/#disqus_thread>Comments</a>
- <a class=label href=https://parsiya.net/categories/semgrep/>semgrep</a></p><h1 class=entry-title>A Few Fun Semgrep Experiments</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#requirements>Requirements</a></li><li><a href=#setup>Setup</a></li><li><a href=#gotchas>Gotchas</a><ul><li><a href=#complete-rule-ids>Complete Rule IDs</a></li><li><a href=#reading-the-json-output>Reading the JSON Output</a></li><li><a href=#output-structs>Output Structs</a><ul><li><a href=#generating-structs>Generating Structs</a></li></ul></li><li><a href=#extracting-metavariables-via-the-message-field>Extracting Metavariables via the Message Field</a></li></ul></li><li><a href=#the-experiments>The Experiments</a><ul><li><a href=#00-running-semgrep>00. Running Semgrep</a></li><li><a href=#exclude-rules>Exclude Rules</a><ul><li><a href=#01-passing-multiple-exclude-rule-switches>01. Passing Multiple exclude-rule Switches</a></li><li><a href=#02-removing-specific-results-from-the-output>02. Removing Specific Results from the Output</a></li></ul></li><li><a href=#03-unit-test-coverage-in-go>03. Unit Test Coverage in Go</a><ul><li><a href=#go-unit-tests>Go Unit Tests</a></li><li><a href=#logic>Logic</a></li><li><a href=#semgrepignore>.semgrepignore</a></li><li><a href=#the-custom-rule>The Custom Rule</a></li><li><a href=#running-semgrep-and-extracting-the-info>Running Semgrep and Extracting the Info</a></li></ul></li><li><a href=#summary-reports>Summary Reports</a><ul><li><a href=#04-text-summary-report>04. Text Summary Report</a></li><li><a href=#05-html-summary-report>05. HTML Summary Report</a></li></ul></li><li><a href=#06-go-function-call-chain>06. Go Function Call Chain</a><ul><li><a href=#bonus-go-package-shenanigans>Bonus Go Package Shenanigans</a></li></ul></li><li><a href=#07-misc-tips-and-tricks>07. Misc Tips and Tricks</a></li></ul></li><li><a href=#what-did-we-learn-here-today>What Did We Learn Here Today?</a></li></ul></nav><p>I want to use Semgrep as a light code intelligence tool with a few experiments.
I will write custom rules to extract info from code and then process the
results.</p><p>The type of these experiments is inspired by <a href=https://github.com/mjambon target=_blank rel="noreferrer noopener">Martin Jambon</a> who is
actually a core Semgrep developer. These are supposed to be self-contained but
short experiments. You can see his at <a href=https://github.com/mjambon/dev-random target=_blank rel="noreferrer noopener">https://github.com/mjambon/dev-random</a>.</p><h1 id=intro>Intro
<a class=header-link href=#intro><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>If you know me, you know I never shut up about Semgrep, see
<a href=https://parsiya.net/categories/semgrep/ target=_blank rel="noreferrer noopener">https://parsiya.net/categories/semgrep/</a>.</p><p>I use Semgrep if I want something quick that works. For complex uses cases, you
need to create your own static analysis tools. Parsing is doable with
<a href=https://tree-sitter.github.io/tree-sitter/ target=_blank rel="noreferrer noopener">tree-sitter</a> (same thing Semgrep uses) and <a href=https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries target=_blank rel="noreferrer noopener">tree-sitter queries</a>.
For Go, I have also used the <a href=https://pkg.go.dev/go/ast target=_blank rel="noreferrer noopener">ast</a> package.</p><h1 id=requirements>Requirements
<a class=header-link href=#requirements><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>This blog assumes you have this knowledge. Nothing fancy.</p><ol><li>Some familiarity with Go.</li><li>Writing basic Semgrep rules.</li></ol><h1 id=setup>Setup
<a class=header-link href=#setup><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>To interact with Semgrep, I have created a couple of wrapper packages in
<a href=https://github.com/parsiya/semgrep_go target=_blank rel="noreferrer noopener">Go</a> and <a href=https://github.com/parsiya/semgrep-rs target=_blank rel="noreferrer noopener">Rust</a>. The overall concept of post-processing
is straightforward:</p><ol><li>Create custom rules that use metavariables to extract specific info from code.</li><li>Create a wrapper to run Semgrep and deserialize the JSON output.</li><li><del>Draw the rest of the owl.</del> Process the output and apply the logic.</li></ol><p>In this blog I will use <a href=https://github.com/parsiya/semgrep_go target=_blank rel="noreferrer noopener">semgrep_go</a>. You can follow along:</p><pre tabindex=0><code>git clone --recurse-submodules https://github.com/parsiya/semgrep-fun
go run main.go 01 code/juice-shop
</code></pre><p>These are simple applications that just do the job. There's not a lot of error
handling.</p><h1 id=gotchas>Gotchas
<a class=header-link href=#gotchas><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Hopefully you don't have to repeat my mistakes. These have taken a few hours of
my life.</p><h2 id=complete-rule-ids>Complete Rule IDs
<a class=header-link href=#complete-rule-ids><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>By default, Semgrep adds some extra text to rule IDs in the results. I call them
"complete rule IDs" and (I think) they're added to prevent rule ID collision.</p><p>For local rules, the complete text depends on the path in <code>--config</code>. E.g., if I
run Semgrep with <code>--config tmp/whatever.yaml</code> and the rule ID is <code>my-rule</code>, the
complete rule ID is <code>tmp.whatever.my-rule</code>.</p><p>Rules in the Semgrep registry follow a similar pattern. It's based on the path
that of the rule in the GitHub repo <a href=https://github.com/semgrep/semgrep-rules target=_blank rel="noreferrer noopener">semgrep/semgrep-rules</a>. E.g., the
complete rule ID for the C <code>double-free</code> rule is
<code>c.lang.security.double-free.double-free</code> because it's in
<code>semgrep-rules/c/lang/security/double-free.yaml</code>. Note the double <code>double-free</code>
(har har) in the end because both the file name and the rule ID are the same.</p><p>Our options when processing the results are:</p><ol><li>Use the complete rule ID. This is doable for registry rules because their ID
is predictable, but not practical for local rules because we might have no
control over their path.</li><li>Check if the rule ID in the results ends with the rule ID from our files with
<a href=https://pkg.go.dev/strings#HasSuffix target=_blank rel="noreferrer noopener">strings.HasSuffix</a>.<ol><li>Don't split by <code>.</code> and compare the last part. I've been bit by this when
the rule ID had periods.</li></ol></li><li>Run Semgrep with <code>--no-rewrite-rule-ids</code> to disable the complete rule ID
generation. We will only the rule ID in the output, but this might lead to
collisions.</li></ol><h2 id=reading-the-json-output>Reading the JSON Output
<a class=header-link href=#reading-the-json-output><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>There are two ways to read the JSON output.</p><ol><li>Tell Semgrep to store the results in a file with the <code>--output</code> switch.<ol><li>This might be removed in the future according to the developers.</li></ol></li><li>Read it from process output.<ol><li>The package uses this option.</li></ol></li></ol><h2 id=output-structs>Output Structs
<a class=header-link href=#output-structs><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>The structure of the output is defined in <a href=https://github.com/semgrep/semgrep-interfaces target=_blank rel="noreferrer noopener">semgrep/semgrep-interfaces</a>.
The source of truth is the atd file, but it's an OCaml thing and I don't know
how to parse it. I rely on the automatically generated JSON schema in
<a href=https://github.com/semgrep/semgrep-interfaces/blob/main/semgrep_output_v1.jsonschema target=_blank rel="noreferrer noopener">semgrep_output_v1.jsonschema</a>.</p><p>I used <a href=https://github.com/omissis/go-jsonschema target=_blank rel="noreferrer noopener">omissis/go-jsonschema</a> (formerly <code>atombender/go-jsonschema</code>)
to generate the Go structs from the JSON schema. From time to time, the schema
might break backwards compatibility.</p><p>Don't upgrade your Semgrep version without checking if the format has changed.
Generate the structs and then do a simple compare to see if anything major has
changed.</p><h3 id=generating-structs>Generating Structs
<a class=header-link href=#generating-structs><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>I use these commands:</p><pre tabindex=0><code>$ git clone https://github.com/semgrep/semgrep-interfaces &amp;&amp; cd semgrep-interfaces
# optional: check out the tag for a specific Semgrep version
$ git checkout v1.52.0

# install go-jsonschema
$ go install github.com/omissis/go-jsonschema/cmd/gojsonschema@latest

# generate the output
# -p output: package name is output
# -o output.go: write the structs to output.go
$ gojsonschema -p output -o output.go --verbose semgrep-interfaces/semgrep_output_v1.jsonschema
</code></pre><p>What I tried and didn't work in Go:
<a href=https://parsiya.io/abandoned-research/semgrep-output-json/ target=_blank rel="noreferrer noopener">https://parsiya.io/abandoned-research/semgrep-output-json/</a>.</p><p>Similar article for Rust: <a href=https://parsiya.net/blog/2022-10-16-yaml-wrangling-with-rust/ target=_blank rel="noreferrer noopener">https://parsiya.net/blog/2022-10-16-yaml-wrangling-with-rust/</a>.</p><h2 id=extracting-metavariables-via-the-message-field>Extracting Metavariables via the Message Field
<a class=header-link href=#extracting-metavariables-via-the-message-field><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>In these examples, I have smuggled the value of metavariables from the message
field. It's convenient and with a bit of smart placement and text processing,
you can get structured data out of it.</p><p>You could also access the values of metavariables from the struct. They can be
accessed via <code>result.Extra.Metavars["$METAVARNAME"]</code>. There are two fields,
<code>AbstractContent</code> and <code>PropagatedValue</code>. Generally, you want the propagated
value (the equivalent of having <code>value($METAVARNAME)</code> in the message field).
For more information please see
<a href=https://semgrep.dev/docs/writing-rules/experiments/display-propagated-metavariable/ target=_blank rel="noreferrer noopener">https://semgrep.dev/docs/writing-rules/experiments/display-propagated-metavariable/</a>.</p><h1 id=the-experiments>The Experiments
<a class=header-link href=#the-experiments><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>The <code>code</code> subdirectory contains the test data as git submodules. Be sure to
populate them with before running the examples. They are:</p><ul><li><a href=https://github.com/juice-shop/juice-shop target=_blank rel="noreferrer noopener">OWASP Juice Shop</a></li><li><a href=https://github.com/sirupsen/logrus target=_blank rel="noreferrer noopener">sirupsen/logrus</a></li></ul><h2 id=00-running-semgrep>00. Running Semgrep
<a class=header-link href=#00-running-semgrep><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>The "official" way to run Semgrep is via the Semgrep command. So my package uses
a wrapper. You can also use the <code>osemgrep</code> binary directly or look into how the
Python wrapper does it.</p><p>I am going to run it on <a href=https://github.com/juice-shop/juice-shop target=_blank rel="noreferrer noopener">OWASP Juice Shop</a> with the <code>p/default</code>
ruleset and then use it in some other examples.</p><p>The <code>semgrep_go</code> package allows us to use some common switches. The <code>Extra</code>
field is a <code>[]string</code> that allows us to pass the rest of the switches. Because
we want to store the output in a file, we will just pass <code>--output</code>. But we can
also have multiple parameters like
<code>[]string{"--no-rewrite-rule-ids", "--severity", "WARN"}</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Setup Semgrep switches.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>opts <span style=color:#719e07>:=</span> run.Options{
</span></span><span style=display:flex><span>    Output:    run.JSON,       <span style=color:#586e75>// Output format is JSON.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    Paths:     []<span style=color:#dc322f>string</span>{path}, <span style=color:#586e75>// &#34;code/juice-shop&#34;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    Rules:     []<span style=color:#dc322f>string</span>{<span style=color:#2aa198>&#34;p/default&#34;</span>},
</span></span><span style=display:flex><span>    Verbosity: run.Debug,
</span></span><span style=display:flex><span>    Extra:     []<span style=color:#dc322f>string</span>{<span style=color:#2aa198>&#34;--output=output/juice-shop.json&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let's run Semgrep. We don't care about the output so we will use <code>Run</code> instead
of <code>RunJSON</code>. We will also ignore the output.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>log.<span style=color:#268bd2>Print</span>(<span style=color:#2aa198>&#34;Running Semgrep, this might take a minute.&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#586e75>// Run Semgrep and ignore the output.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>_, err <span style=color:#719e07>:=</span> opts.<span style=color:#268bd2>Run</span>()
</span></span><span style=display:flex><span><span style=color:#719e07>return</span> err
</span></span></code></pre></div><p>Read <code>output/juice-shop.json</code> and parse it with <code>jq</code>. This example shows the
ruleID and path of every hit.</p><pre tabindex=0><code>$ jq &#39;.results[] | &#34;ruleid: &#34; + .check_id + &#34; - path: &#34; + .path&#39; output/juice-shop.json
</code></pre><span class=caption-wrapper><img class=caption src=00.png title="See the complete rule IDs" alt="See the complete rule IDs">
<span class=caption-text>See the complete rule IDs</span></span><h2 id=exclude-rules>Exclude Rules
<a class=header-link href=#exclude-rules><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>Objective: Remove results for specific rules.</p><p>Let's start with something easy. We've used a ruleset/rulepack, but we want to
ignore results from certain rules instead of modifying it directly to remove
those rules. We can do it in two ways:</p><ol><li>Use multiple <code>--exclude-rule</code> switches.</li><li>Process the results and delete the hits from excluded rules.</li></ol><p>Our example is running Semgrep with the <code>p/default</code> ruleset on
<a href=https://github.com/juice-shop/juice-shop target=_blank rel="noreferrer noopener">OWASP Juice Shop</a> in <code>code/juice-shop</code>.</p><h3 id=01-passing-multiple-exclude-rule-switches>01. Passing Multiple exclude-rule Switches
<a class=header-link href=#01-passing-multiple-exclude-rule-switches><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>The <a href=https://github.com/parsiya/semgrep_go target=_blank rel="noreferrer noopener">semgrep-go</a> package allows us to pass command line switches to
Semgrep. We could have used <code>jq</code> to process JSON on the command line, too, but I
rather use Go in a proper program especially if the list of excluded rules is
big or dynamic.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// fun/01_exclude_switch.go
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// In the real world we will get a long list from somewhere.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>excludedRules <span style=color:#719e07>:=</span> []<span style=color:#dc322f>string</span>{
</span></span><span style=display:flex><span>    <span style=color:#2aa198>&#34;javascript.audit.detect-replaceall-sanitization.detect-replaceall-sanitization&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#268bd2>var</span> extra []<span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Add all the excluded rules like a `--exclude-rule=[ID]` argument.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>for</span> _, r <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> excludedRules {
</span></span><span style=display:flex><span>    extra = <span style=color:#b58900>append</span>(extra, <span style=color:#2aa198>&#34;--exclude-rule=&#34;</span><span style=color:#719e07>+</span>r)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Excluding results for: %s&#34;</span>, excludedRules)
</span></span></code></pre></div><p>Add the extra switches in the <code>Extra</code> field.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Setup Semgrep switches.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>opts <span style=color:#719e07>:=</span> run.Options{
</span></span><span style=display:flex><span>    Output:    run.JSON,       <span style=color:#586e75>// Output format is JSON.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    Paths:     []<span style=color:#dc322f>string</span>{path}, <span style=color:#586e75>// &#34;code/juice-shop&#34;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    Rules:     []<span style=color:#dc322f>string</span>{<span style=color:#2aa198>&#34;p/default&#34;</span>},
</span></span><span style=display:flex><span>    Verbosity: run.Debug,
</span></span><span style=display:flex><span>    Extra:     extra, <span style=color:#586e75>// Items in Extra will be added to the CLI as-is.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>Run Semgrep and deserialize the output.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>log.<span style=color:#268bd2>Print</span>(<span style=color:#2aa198>&#34;Running Semgrep, this might take a minute.&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#586e75>// Run Semgrep and get the deserialized output.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>out, err <span style=color:#719e07>:=</span> opts.<span style=color:#268bd2>RunJSON</span>()
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Loop through the hits/findings/matches in the deserialized output and check
ruleIDs against the exclusions.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Check if any of the ruleIDs match what we wanted to exclude.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>for</span> _, hit <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> out.Results {
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> strings.<span style=color:#268bd2>Contains</span>(hit.<span style=color:#268bd2>RuleID</span>(), <span style=color:#2aa198>&#34;detect-replaceall-sanitization&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Found a rule that should have been excluded.&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The field name for ruleID in the output is actually <code>CheckId</code>. So I have a
<code>RuleID()</code> method. Finally, we use the package to create an ASCII table of all
ruleIDs and their number of hits.</p><p>If you've cloned the <a href=https://github.com/parsiya/semgrep-fun target=_blank rel="noreferrer noopener">semgrep-fun</a> repo, run
<code>go run main.go 01 code/juice-shop</code>.</p><span class=caption-wrapper><img class=caption src=01.png title="Excluding rules with CLI switches" alt="Excluding rules with CLI switches">
<span class=caption-text>Excluding rules with CLI switches</span></span><h3 id=02-removing-specific-results-from-the-output>02. Removing Specific Results from the Output
<a class=header-link href=#02-removing-specific-results-from-the-output><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>The results might come from a pipeline where cannot modify the Semgrep command.
In this experiment, I will process the deserialized output and remove all hits
with the specific rule IDs.</p><p>Instead of running Semgrep again, I will use the output from section 00 in
<code>output/juice-shop.json</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Read the data in &#34;output/juice-shop.json&#34;.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>data, err <span style=color:#719e07>:=</span> os.<span style=color:#268bd2>ReadFile</span>(<span style=color:#2aa198>&#34;output/juice-shop.json&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#586e75>// Deserialize the data.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>out, err <span style=color:#719e07>:=</span> output.<span style=color:#268bd2>Deserialize</span>(data)
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>out</code> has our deserialized results.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Create a new slice to hold the modified results.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>var</span> modifiedResults []output.CliMatch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Loop through the results.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>for</span> _, hit <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> out.Results {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Check if the hit&#39;s ruleID matches any of the excluded rules.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> slices.<span style=color:#268bd2>Contains</span>(excludedRules, hit.<span style=color:#268bd2>RuleID</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// If it does, skip it.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#586e75>// If the ruleID is not excluded, add it to modifiedResults.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    modifiedResults = <span style=color:#b58900>append</span>(modifiedResults, hit)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Replace the results with the modified results.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>out.Results = modifiedResults
</span></span></code></pre></div><p>Note how we are replacing the results in the original object. We can serialize
the modified object back to JSON and pass it to the next step of the pipeline.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>js, err <span style=color:#719e07>:=</span> out.<span style=color:#268bd2>Serialize</span>(<span style=color:#cb4b16>true</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run this command to see it in action:
<code>go run main.go 02 code/juice-shop</code>.</p><span class=caption-wrapper><img class=caption src=02.png title="Summary of results" alt="Summary of results">
<span class=caption-text>Summary of results</span></span><h2 id=03-unit-test-coverage-in-go>03. Unit Test Coverage in Go
<a class=header-link href=#03-unit-test-coverage-in-go><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>Objective: Which functions in a package have unit tests.</p><h3 id=go-unit-tests>Go Unit Tests
<a class=header-link href=#go-unit-tests><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>TL;DR:</p><ol><li>Assume function is <code>Func1</code> in file <code>func1.go</code>.</li><li>Test is function <code>TestFunc1</code> in file <code>func1_test.go</code> in the same package.</li></ol><p>I usually use the <code>vscode-go</code> extension to
<a href=https://code.visualstudio.com/docs/languages/go#_test. target=_blank rel="noreferrer noopener">generate test skeletons</a>. Works better than AI, tbh.</p><h3 id=logic>Logic
<a class=header-link href=#logic><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><ol><li>Extract all function names with their package and file names.<ol><li>The package name can reduce false positives for identical names in
different packages.</li></ol></li><li>Go through the list of functions and filter the noise.<ol><li>(optional) Select functions that are not in files that end in <code>_test.go</code>.</li><li>(optional) Select functions that are exported (start with a capital letter).</li></ol></li><li>Check each function has a test. E.g., for <code>Func1</code> do:<ol><li>Does <code>TestFunc1</code> exist in the same package?<ol><li>If not, log there's no test.</li></ol></li><li>If so, is it in the <code>func1_test.go</code>?<ol><li>If not, log the test is in the wrong place.</li></ol></li><li>Log <code>Func1</code> has a test in the correct location.</li></ol></li></ol><h3 id=semgrepignore>.semgrepignore
<a class=header-link href=#semgrepignore><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Semgrep ignores <a href=https://semgrep.dev/docs/ignoring-files-folders-code/#understanding-semgrep-defaults target=_blank rel="noreferrer noopener">certain test files and paths</a> (among other
things). See everything in the <a href=https://github.com/semgrep/semgrep/blob/develop/cli/src/semgrep/templates/.semgrepignore target=_blank rel="noreferrer noopener">default .semgrepignore file</a>.
We want to scan the test files.</p><p>To make Semgrep scan test files we create an empty <code>.semgrepignore</code> file in the
current working directory before we run Semgrep and delete it after.</p><h3 id=the-custom-rule>The Custom Rule
<a class=header-link href=#the-custom-rule><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>This is a custom rule that collects:</p><ol><li>Package name</li><li>Function name</li></ol><p>We also need the file name but that's done in the post-processing part.</p><p>The rule will look like this. This is the experimental rule syntax. Here's a
<a href=/blog/2023-10-28-semgreps-experimental-rule-syntax/ title=tutorial rel=nofollow target=_blank>tutorial</a>.
I have also included the old rule syntax.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#268bd2>id</span>: blog-2023-11-go-function-extract
</span></span><span style=display:flex><span>    <span style=color:#268bd2>match</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>all</span>:
</span></span><span style=display:flex><span>        - <span style=color:#268bd2>inside</span>: |<span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            package $PKG
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            ...</span>            
</span></span><span style=display:flex><span>        - func $FUNC(...)
</span></span><span style=display:flex><span>    <span style=color:#586e75># patterns:</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>#   - pattern-inside: |</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>#       package $PKG</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>#       ...</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>#   - pattern: func $FUNC(...)</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>message</span>: $PKG - $FUNC
</span></span><span style=display:flex><span>    <span style=color:#268bd2>languages</span>:
</span></span><span style=display:flex><span>      - go 
</span></span><span style=display:flex><span>    <span style=color:#268bd2>severity</span>: WARNING
</span></span></code></pre></div><p>You can see the rule in action at:
<a href=https://semgrep.dev/playground/r/zdUKA4D/parsiya.blog-2023-11-go-function-extract target=_blank rel="noreferrer noopener">https://semgrep.dev/playground/r/zdUKA4D/parsiya.blog-2023-11-go-function-extract</a></p><h3 id=running-semgrep-and-extracting-the-info>Running Semgrep and Extracting the Info
<a class=header-link href=#running-semgrep-and-extracting-the-info><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Rule messages are in the form of <code>$PKG - $FUNC</code>. We will need three pieces of
information:</p><ol><li>Package name: In message.</li><li>Function name: In message.</li><li>File path: In <code>.Path</code> or using the helper method <code>.FilePath()</code>.</li></ol><p>Then it becomes a DSA problem and you can skip reading the rest of the section
if you want to.</p><p>First, we create a <code>FuncInfo</code> object for each function:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// FuncInfo contains information about a function.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> FuncInfo <span style=color:#268bd2>struct</span> {
</span></span><span style=display:flex><span>	Package <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>	Name    <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>	Path    <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And create a map where the key is a package name and the members are the
functions in that package.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// FuncList is a map where key is the package name and the value is FuncMap.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> FuncList <span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]FuncMap
</span></span></code></pre></div><p>Then we can easily populate these from the results:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Loop through the results.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>for</span> _, hit <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> out.Results {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// $PKG - $FUNC
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    msg <span style=color:#719e07>:=</span> strings.<span style=color:#268bd2>Split</span>(hit.<span style=color:#268bd2>Message</span>(), <span style=color:#2aa198>&#34; - &#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#586e75>// msg[0]: $PKG
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// msg[1]: $FUNC
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Note we&#39;re not doing a lot of error checking here.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(msg) <span style=color:#719e07>!=</span> <span style=color:#2aa198>2</span> {
</span></span><span style=display:flex><span>        log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Wrong message, got: %s&#34;</span>, hit.<span style=color:#268bd2>Message</span>())
</span></span><span style=display:flex><span>        <span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Store the function info in a FuncInfo struct.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    fn <span style=color:#719e07>:=</span> FuncInfo{
</span></span><span style=display:flex><span>        Package: msg[<span style=color:#2aa198>0</span>],
</span></span><span style=display:flex><span>        Name:    msg[<span style=color:#2aa198>1</span>],
</span></span><span style=display:flex><span>        Path:    hit.<span style=color:#268bd2>FilePath</span>(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> _, ok <span style=color:#719e07>:=</span> funcList[fn.Package]; !ok {
</span></span><span style=display:flex><span>        funcList[fn.Package] = <span style=color:#b58900>make</span>(FuncMap)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    funcList[fn.Package][fn.Name] = fn
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We could use this map to extract any info we want. We can also use another trick
here. In Go, the tests belong to the same package so we can just create a list
of functions in each package and then do a search in an array of strings.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>data <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([][]<span style=color:#dc322f>string</span>, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Now, we have a map of all functions in code, we can go through the
</span></span></span><span style=display:flex><span><span style=color:#586e75>// functions in each package and check if they have a test.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>for</span> _, funcs <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> funcList {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// It&#39;s easier to create a slice of all functions in a package for
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// searching.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#268bd2>var</span> funcNames []<span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> _, fn <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> funcs {
</span></span><span style=display:flex><span>        funcNames = <span style=color:#b58900>append</span>(funcNames, fn.Name)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// [next section with the checks]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>Then we can go through each function and check if it has a test in the same
package by using <code>string.Contains</code>. We're also saving a few cycles by skipping
test functions (in files ending in <code>_tests.go</code>).</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>for</span> _, fn <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> funcs {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Skip functions in `*_test.go` files.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> strings.<span style=color:#268bd2>HasSuffix</span>(fn.Path, <span style=color:#2aa198>&#34;_test.go&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Check if the function has a test. AKA &#34;Test&#34;+fn.Name is in the
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// package.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> slices.<span style=color:#268bd2>Contains</span>(funcNames, <span style=color:#2aa198>&#34;Test&#34;</span><span style=color:#719e07>+</span>fn.Name) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Add the functions with missing tests to the data slice.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    data = <span style=color:#b58900>append</span>(data, []<span style=color:#dc322f>string</span>{fn.Name, fn.Package, fn.Path})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running it on <code>code/logrus</code> gives us this table. But you can pass the path to
any other Go code to the command line.</p><span class=caption-wrapper><img class=caption src=03.png title="List of functions in logrus" alt="List of functions in logrus">
<span class=caption-text>List of functions in logrus</span></span><h2 id=summary-reports>Summary Reports
<a class=header-link href=#summary-reports><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>You run Semgrep and get a bunch of results. If you want to review the results,
you should use the <code>--sarif</code> switch and use a <a href=https://sarifweb.azurewebsites.net/ target=_blank rel="noreferrer noopener">SARIF</a> viewer. I usually
use the VS Code SARIF plugin. It allows me to look at the issue in the editor.</p><p>But we can also process the output and create reports with specific items. The
<code>semgrep_go</code> package supports creating two types of tables:</p><ol><li>Count by rule ID</li><li>Count by file path</li></ol><p>We're going to use the output of running <code>p/default</code> on <a href=https://github.com/juice-shop/juice-shop target=_blank rel="noreferrer noopener">Juice Shop</a>
from before.</p><h3 id=04-text-summary-report>04. Text Summary Report
<a class=header-link href=#04-text-summary-report><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Let's create a simple ASCII report. We will create two tables. First one shows
us high impact rules and the second one, files with highest number of findings.
Generally, we want to have the rule IDs and files with the highest number of
findings at the top, this is done by passing <code>true</code> to the two functions below.
If we pass <code>false</code>, the tables will be sorted by rule ID or file path
alphabetically.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// fun/04_text_report.go
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// [Removed]
</span></span></span><span style=display:flex><span><span style=color:#586e75>// The deserialized results are in `out`.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Create the reports.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>ruleIDTextReport <span style=color:#719e07>:=</span> out.<span style=color:#268bd2>RuleIDTextReport</span>(<span style=color:#cb4b16>true</span>)
</span></span><span style=display:flex><span>filePathTextReport <span style=color:#719e07>:=</span> out.<span style=color:#268bd2>FilePathTextReport</span>(<span style=color:#cb4b16>true</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Print the reports.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>log.<span style=color:#268bd2>Print</span>(<span style=color:#2aa198>&#34;Rule ID report:&#34;</span>)
</span></span><span style=display:flex><span>log.<span style=color:#268bd2>Print</span>(ruleIDTextReport)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log.<span style=color:#268bd2>Print</span>(<span style=color:#2aa198>&#34;File Path Report:&#34;</span>)
</span></span><span style=display:flex><span>log.<span style=color:#268bd2>Print</span>(filePathTextReport)
</span></span></code></pre></div><p>This time instead of passing the code base path, we will pass the output file
from section 00. The program will print two text tables.
<code>go run main.go 04 output/juice-shop.json</code></p><span class=caption-wrapper><img class=caption src=04.png title="Summary report" alt="Summary report">
<span class=caption-text>Summary report</span></span><h3 id=05-html-summary-report>05. HTML Summary Report
<a class=header-link href=#05-html-summary-report><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>For the HTML summary report, I wanted to make something similar to the Semgrep
outline. We can create a template using the Go <a href=https://pkg.go.dev/html/template target=_blank rel="noreferrer noopener">html/template</a> package
and apply it to the output object. This is going to look ugly, but good enough
for an example.</p><p>The code is similar to the previous section. We will deserialize the result and
create a report struct.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// fun/05_html_report.go
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Report contains the information in the HTML report.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> Report <span style=color:#268bd2>struct</span> {
</span></span><span style=display:flex><span>	NumberOfFindings <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	ByRuleID         []output.HitMapRow
</span></span><span style=display:flex><span>	ByFilePath       []output.HitMapRow
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>HTMLReport</span>(path <span style=color:#dc322f>string</span>) <span style=color:#dc322f>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// [Removed]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// The deserialized results are in `out`.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// Create the report object.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    rep <span style=color:#719e07>:=</span> Report{
</span></span><span style=display:flex><span>        NumberOfFindings: <span style=color:#b58900>len</span>(out.Results),
</span></span><span style=display:flex><span>        ByRuleID:         out.<span style=color:#268bd2>RuleIDHitMap</span>(<span style=color:#cb4b16>true</span>),
</span></span><span style=display:flex><span>        ByFilePath:       out.<span style=color:#268bd2>FilePathHitMap</span>(<span style=color:#cb4b16>true</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#586e75>// removed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>Then we will pass to an HTML template which uses the built-in Go template engine.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// embed the 05-report-html-tmpl.html in a string.
</span></span></span><span style=display:flex><span><span style=color:#586e75>//
</span></span></span><span style=display:flex><span><span style=color:#586e75>//go:embed 05-report-html-template.html
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>var</span> tmpl <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>HTMLReport</span>(path <span style=color:#dc322f>string</span>) <span style=color:#dc322f>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// removed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Apply the template.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	t, err <span style=color:#719e07>:=</span> template.<span style=color:#268bd2>New</span>(<span style=color:#2aa198>&#34;report&#34;</span>).<span style=color:#268bd2>Parse</span>(tmpl)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> data bytes.Buffer
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err = t.<span style=color:#268bd2>Execute</span>(<span style=color:#719e07>&amp;</span>data, rep); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#586e75>// removed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div><p>We will write the resulting HTML report to <code>output/05-report.html</code>. You can also
see it in the cloned repo.</p><p><code>go run main.go 05 output/juice-shop.json</code></p><span class=caption-wrapper><img class=caption src=05.png title="Graphic design is my passion" alt="Graphic design is my passion">
<span class=caption-text>Graphic design is my passion</span></span><h2 id=06-go-function-call-chain>06. Go Function Call Chain
<a class=header-link href=#06-go-function-call-chain><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>This is a simple function call chain experiment.</p><p>Probably the most straightforward way of doing this would be with a rule like
this rule.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#268bd2>id</span>: go-function-chain
</span></span><span style=display:flex><span>  <span style=color:#268bd2>patterns</span>:
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-inside</span>: |<span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        package $PKG
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        ...</span>        
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-inside</span>: |<span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        func $CALLER(...) {...}</span>        
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-either</span>:
</span></span><span style=display:flex><span>        - <span style=color:#268bd2>pattern</span>: $CALLEE(...)
</span></span><span style=display:flex><span>        - <span style=color:#268bd2>pattern</span>: $IMP.$CALLEE(...)
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>metavariable-regex</span>:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>metavariable</span>: $CALLEE
</span></span><span style=display:flex><span>        <span style=color:#268bd2>regex</span>: ^[^.]*$
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>focus-metavariable</span>: $CALLEE
</span></span><span style=display:flex><span>  <span style=color:#268bd2>message</span>: $PKG - $CALLER - $CALLEE - $IMP
</span></span><span style=display:flex><span>  <span style=color:#268bd2>languages</span>:
</span></span><span style=display:flex><span>    - go
</span></span><span style=display:flex><span>  <span style=color:#268bd2>severity</span>: WARNING
</span></span></code></pre></div><p>We're looking for two types of calls:</p><ol><li>Local package functions: <code>$CALLEE(...)</code></li><li>Imported functions: <code>$IMP.$CALLEE(...)</code></li></ol><p>Playground link: <a href=https://semgrep.dev/playground/r/oqUgbKy/parsiya.go-function-chain target=_blank rel="noreferrer noopener">https://semgrep.dev/playground/r/oqUgbKy/parsiya.go-function-chain</a></p><p>I had to fix two issues with this pattern:</p><p>First, Imported functions like <code>strings.Contains</code> are captured twice, one as
<code>$CALLEE: strings.Contains</code> and the other as
<code>$IMP: strings, $CALLEE = Contains</code>. The <code>metavariable-regex</code> looks for the
literal dot in <code>$CALLEE</code> and drops the first match.</p><p>Second, we're only capturing the top-level package name instead of the complete
name. So if two different packages have the same top-level package and function
names, we have a collision.</p><p>We can track all imports in each file. The pattern will be <code>import $IMPORT</code> and
we will group the results by file path. Now, we can create the complete package
name for each file.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#268bd2>id</span>: go-import-collection
</span></span><span style=display:flex><span>  <span style=color:#268bd2>patterns</span>:
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-inside</span>: |<span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        package $PKG
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        ...</span>        
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-either</span>:
</span></span><span style=display:flex><span>      - <span style=color:#268bd2>patterns</span>:
</span></span><span style=display:flex><span>          - <span style=color:#268bd2>pattern</span>: import &#34;$IMPORT&#34;
</span></span><span style=display:flex><span>          - <span style=color:#268bd2>pattern-not</span>: import $ALIAS &#34;$IMPORT&#34;
</span></span><span style=display:flex><span>      - <span style=color:#268bd2>pattern</span>: import $ALIAS &#34;$IMPORT&#34;
</span></span><span style=display:flex><span>  <span style=color:#268bd2>message</span>: $PKG - $ALIAS - $IMPORT
</span></span><span style=display:flex><span>  <span style=color:#268bd2>focus-metavariable</span>: $IMPORT
</span></span><span style=display:flex><span>  <span style=color:#268bd2>languages</span>:
</span></span><span style=display:flex><span>    - go
</span></span><span style=display:flex><span>  <span style=color:#268bd2>severity</span>: WARNING
</span></span></code></pre></div><p>Playground link: <a href=https://semgrep.dev/playground/r/2ZUzvdK/parsiya.go-import-collection target=_blank rel="noreferrer noopener">https://semgrep.dev/playground/r/2ZUzvdK/parsiya.go-import-collection</a>
When processing the results from this rule, we have to filter out the text
<code>$ALIAS</code> in the message which happens when the package is not imported as an
alias. Alternatively, we could have two rules. One for each pattern.</p><p>The rest of the processing is kind of straightforward.</p><p>The <code>go-import-collection</code> rule returns each package's alias (if it exists) and
its complete name. We create an <code>ImportMap</code> for each file. It's a
<code>map[string]string</code> where the key is the top-level package name (e.g., <code>bar</code> for
<code>github.com/foo/bar</code>) or its import alias (e.g., <code>bar</code> for
<code>import bar "github.com/foo/bar"</code>).</p><p>All of these go into a different map where the key is the file path and value is
the import map.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// ImportMap is map of one file&#39;s imports.
</span></span></span><span style=display:flex><span><span style=color:#586e75>//
</span></span></span><span style=display:flex><span><span style=color:#586e75>// Key: Alias if it exists or the top-level package if not (e.g., &#34;bar&#34; for
</span></span></span><span style=display:flex><span><span style=color:#586e75>// &#34;github.com/foo/bar&#34;).
</span></span></span><span style=display:flex><span><span style=color:#586e75>//
</span></span></span><span style=display:flex><span><span style=color:#586e75>// Value: Complete package name.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> ImportMap <span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]<span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Imports is a map of file paths to their imports. Key is file path.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> Imports <span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]ImportMap
</span></span></code></pre></div><p><code>go-function-chain</code> returns the function name, package name, and file path for
each function. This is enough to identify each function in code. The file path
helps prevent collisions when two packages have the same name in different
parent packages. E.g., <code>github.com/foo/bar</code> and <code>github.com/baz/bar</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// Function represents one function.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> Function <span style=color:#268bd2>struct</span> {
</span></span><span style=display:flex><span>	Package  <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>	Name     <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>	FilePath <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The final result is still undercooked and has two issues:</p><ol><li>It only goes down one level. E.g., caller to callee.</li><li>Object methods are not recognized properly. E.g.,
<code>runtime.FuncForPC(pcs[i]).Name()</code> has package name of
<code>runtime.FuncForPC(pcs[i])</code> which is wrong.</li></ol><p>But we have enough information to create a decent call chain.</p><h3 id=bonus-go-package-shenanigans>Bonus Go Package Shenanigans
<a class=header-link href=#bonus-go-package-shenanigans><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Go packages are special. All files in the same package can be merged into one
big file without parsing issues. When dealing with Go packages, we can use this
to our advantage and treat each package as one big file. This helps with
intra-package analysis because we can simplify our rules.</p><p><strong>There's one issue</strong>. When you merge everything under the hood before Semgrep
analysis, the results will have points to the merged file (e.g., line 15 of the
merged.go). We have to modify the results and translate them back to the
original files because the user did not see our pre-processing.</p><p>This has a simple solution. We have the code snippet with the result, we can
just search it in the original files. I did not expect it to be this simple. I
was creating a map of offsets to track which offset is from which file, but this
solution is just easier.</p><h2 id=07-misc-tips-and-tricks>07. Misc Tips and Tricks
<a class=header-link href=#07-misc-tips-and-tricks><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>At this point I have been sporadically writing this blog for almost two months
so I just wanna finish it. Here are some other tips and tricks, you can read
more at <a href=https://parsiya.io/research/semgrep-tips/ target=_blank rel="noreferrer noopener">https://parsiya.io/research/semgrep-tips/</a>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#586e75># Download a ruleset yaml file.</span>
</span></span><span style=display:flex><span>$ wget https://semgrep.dev/c/p/<span style=color:#719e07>{</span>ruleset-name<span style=color:#719e07>}</span> -O file.yaml
</span></span><span style=display:flex><span><span style=color:#586e75># Example</span>
</span></span><span style=display:flex><span>$ wget https://semgrep.dev/c/p/default -O default.yaml
</span></span></code></pre></div><p>Run all rules <code>--config r/all</code>.</p><p>Check if a specific file exists. E.g., <code>/path/to/badfile.ext</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#268bd2>id</span>: detect-file
</span></span><span style=display:flex><span>  <span style=color:#268bd2>patterns</span>:
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>pattern-regex</span>: .*
</span></span><span style=display:flex><span>  <span style=color:#268bd2>message</span>: Semgrep found the file
</span></span><span style=display:flex><span>  <span style=color:#268bd2>languages</span>:
</span></span><span style=display:flex><span>    - generic
</span></span><span style=display:flex><span>  <span style=color:#268bd2>severity</span>: WARNING
</span></span><span style=display:flex><span>  <span style=color:#268bd2>paths</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>include</span>:
</span></span><span style=display:flex><span>      - /path/to/badfile*
</span></span><span style=display:flex><span>    <span style=color:#268bd2>exclude</span>:
</span></span><span style=display:flex><span>      - /paths/to/exclude/*
</span></span></code></pre></div><h1 id=what-did-we-learn-here-today>What Did We Learn Here Today?
<a class=header-link href=#what-did-we-learn-here-today><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>We learned to process Semgrep output results. With handcrafted rules, we can
extract so much information from Semgrep results.</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Parsia</span></span>
<time>Jan 21, 2024</time></span></p><p class=meta><a class="basic-alignment left" href=https://parsiya.net/blog/sans-holiday-hack-2023/ title="Some SANS Holiday Hack 2023 Solutions">Some SANS Holiday Hack 2023 Solutions</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//parsiya.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I?</h1><p><p>I am Parsia, an application security engineer.</p><p>I write about application security, cryptography, static analysis, and
(of course) videogames.</p><p>Click on <a href=/about/>About Me!</a> to know more.</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="me noopener noreferrer" href=https://infosec.exchange/@parsiya title=https://infosec.exchange/@parsiya><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://github.com/parsiya/ title=https://github.com/parsiya/><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://twitter.com/cryptogangsta/ title=https://twitter.com/cryptogangsta/><i class="fa fa-twitter fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/parsiya title=https://www.linkedin.com/in/parsiya><i class="fa fa-linkedin fa-3x"></i></a></li></ul><section class=odd><h1>Collections</h1><li><a href=https://parsiya.net/categories/thick-client-proxying/ title="Thick Client Proxying">Thick Client Proxying</a></li><li><a href=https://parsiya.net/categories/writeup/ title=CTFs/Writeups>CTFs/Writeups</a></li><li><a href=https://parsiya.net/categories/attack-surface-analysis/ title="Attack Surface Analysis">Attack Surface Analysis</a></li><li><a href=https://parsiya.net/categories/semgrep/ title=Semgrep>Semgrep</a></li><li><a href=https://parsiya.net/categories/bug-bounty/ title="Bug Bounty">Bug Bounty</a></li><li><a href=https://parsiya.net/categories/blockchain/ title="Blockchain (lol)">Blockchain (lol)</a></li><li><a href=https://parsiya.net/categories/crypto/ title=Crypto(graphy)>Crypto(graphy)</a></li><li><a href=https://parsiya.net/categories/burp-extension/ title="Burp Extension Development">Burp Extension Development</a></li><li><a href=https://parsiya.net/categories/automation/ title=Automation>Automation</a></li><li><a href=https://parsiya.net/categories/reverse-engineering/ title="Reverse Engineering">Reverse Engineering</a></li><li><a href=https://parsiya.net/categories/winappdbg/ title="WinAppDbg (use Frida instead)">WinAppDbg (use Frida instead)</a></li><li><a href=https://awsome.pw title='AWSome.pw - S3 bucket squatting - my very "legit" branded vulnerability'>AWSome.pw - S3 bucket squatting - my very "legit" branded vulnerability</a></li></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2024 Parsia - <a href=https://parsiya.net/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>