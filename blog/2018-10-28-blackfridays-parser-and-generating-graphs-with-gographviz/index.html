<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Blackfriday's Parser and Generating graphs with gographviz</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://parsiya.net/favicon.png rel=icon><meta name=description content><meta name=keywords content="[Parsia Hakimian Parsiya infosec information security]"><meta name=author content="Parsia"><meta name=generator content="Hugo 0.122.0"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image:src content="https://parsiya.net/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/04.png"><meta name=twitter:title content="Blackfriday's Parser and Generating graphs with gographviz"><meta name=twitter:description content="I have been working on a personal automation project. In short, I write most of my notes in markdown so I wanted to grab them and store them in a specific format with annotations (e.g. everything under heading deployment notes is labeled as such in the final data file). These are not high volume, large files. I have written them manually, I am talking about a 10-20 KB file (with most content being pasted code/request snippets). I am not looking for efficiency.
Blackfriday is the markdown parser for Hugo, so I was somewhat familiar with it. Since version 2, it has a markdown parser.
In this post, I am going to describe what I learned during the process and how I leveraged Blackfriday's markdown parser in some hacky ways to get annotated data. To visualize the AST (Abstract Syntax Tree) generated by Blackfriday, I used gographviz.
A simple package parse and code can be found here:

https://github.com/parsiya/Parsia-Code/tree/master/markdown-parsing
"><meta name=twitter:domain content="parsiya.net"><meta name=twitter:creator content="@CryptoGangsta"></head><body><header role=banner><hgroup><h1><a href=https://parsiya.net/>Hackerman's Hacking Tutorials</a></h1><h2>The knowledge of anything, since all things have causes, is not acquired or
complete unless it is known by its causes. - Avicenna</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://parsiya.net/about/>» About Me!</option><option value=https://parsiya.net/cheatsheet/>» Cheat Sheet</option><option value=https://parsiya.io/>» My Clone</option><option value=https://github.com/parsiya/parsiya.net>» Source Repo</option><option value="https://queue.acm.org/detail.cfm?id=3197520">» Manual Work is a Bug</option><option value="https://www.google.com/search?q=andrew+ridgeley">» The Other Guy from Wham!</option></select></fieldset><ul class=main-navigation><li><a href=https://parsiya.net/about/ title="About Me!" target=_blank rel="noopener noreferrer">About Me!</a></li><li><a href=https://parsiya.net/cheatsheet/ title="Cheat Sheet" target=_blank rel="noopener noreferrer">Cheat Sheet</a></li><li><a href=https://parsiya.io/ title="My Clone" target=_blank rel="noopener noreferrer">My Clone</a></li><li><a href=https://github.com/parsiya/parsiya.net title="Source Repo" target=_blank rel="noopener noreferrer">Source Repo</a></li><li><a href="https://queue.acm.org/detail.cfm?id=3197520" title="Manual Work is a Bug" target=_blank rel="noopener noreferrer">Manual Work is a Bug</a></li><li><a href="https://www.google.com/search?q=andrew+ridgeley" title="The Other Guy from Wham!" target=_blank rel="noopener noreferrer">The Other Guy from Wham!</a></li></ul><ul class=subscription><a href=https://parsiya.net/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://parsiya.net/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Oct 28, 2018
- 13 minute read
- <a href=https://parsiya.net/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/#disqus_thread>Comments</a>
- <a class=label href=https://parsiya.net/categories/go/>Go </a><a class=label href=https://parsiya.net/categories/not-security/>Not Security </a><a class=label href=https://parsiya.net/categories/lessons-learned/>Lessons Learned</a></p><h1 class=entry-title>Blackfriday's Parser and Generating graphs with gographviz</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><a href=#problem-statement>Problem Statement</a></li><li><a href=#solution>Solution</a><ul><li><a href=#test-data>Test Data</a></li><li><a href=#level-one-heading-and-their-content>Level-One Heading and Their Content</a></li><li><a href=#markdown-to-html-with-blackfriday>Markdown to HTML with Blackfriday</a></li><li><a href=#blackfridays-markdown-ast>Blackfriday's Markdown AST</a><ul><li><a href=#nodevisitor>NodeVisitor</a></li><li><a href=#print-everything>Print Everything</a></li><li><a href=#ast-visualization-with-gographviz>AST Visualization with gographviz</a></li><li><a href=#a-closer-look-at-headings>A Closer Look at Headings</a></li><li><a href=#a-closer-look-at-lists>A Closer Look at Lists</a></li></ul></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><p>I have been working on a personal automation project. In short, I write most of my notes in markdown so I wanted to grab them and store them in a specific format with annotations (e.g. everything under heading <code>deployment notes</code> is labeled as such in the final data file). These are not high volume, large files. I have written them manually, I am talking about a 10-20 KB file (with most content being pasted code/request snippets). I am not looking for efficiency.</p><p><a href=https://godoc.org/gopkg.in/russross/blackfriday.v2 target=_blank rel="noreferrer noopener">Blackfriday</a> is the markdown parser for <a href=https://github.com/gohugoio/hugo target=_blank rel="noreferrer noopener">Hugo</a>, so I was somewhat familiar with it. Since version 2, it has a markdown parser.</p><p>In this post, I am going to describe what I learned during the process and how I leveraged Blackfriday's markdown parser in some hacky ways to get annotated data. To visualize the AST (Abstract Syntax Tree) generated by Blackfriday, I used <a href=https://github.com/awalterschulze/gographviz target=_blank rel="noreferrer noopener">gographviz</a>.</p><p>A simple package <code>parse</code> and code can be found here:</p><ul><li><a href=https://github.com/parsiya/Parsia-Code/tree/master/markdown-parsing target=_blank rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/markdown-parsing</a></li></ul><h1 id=problem-statement>Problem Statement
<a class=header-link href=#problem-statement><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Given a markdown file with the following structure, grab data and annotate them.</p><ol><li>The file can have multiple level-one (e.g. <code># title</code>) headings.</li><li>Each level-one heading has multiple sub-headings. All sub-headings are considered level-two headings (even if they are not) and treated equally.</li><li>The content of each sub-heading must be annotated with the title of that sub-heading.</li><li>The content of sub-headings can be one of the two following forms:<ul><li>Free form: Free form text can be markdown or plaintext. It's passed to Blackfriday and the HTML result is stored in the final data file.</li><li>Lists: Lists are used to create lists of items. Lists can have two levels. Each sub-level is associated with its previous level.</li></ul></li></ol><h1 id=solution>Solution
<a class=header-link href=#solution><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>The solution will not pass coding interviews. But I decline all coding interviews anyway, checkmate <del>atheists</del> interviewers.</p><h2 id=test-data>Test Data
<a class=header-link href=#test-data><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>I will use this data:</p><pre tabindex=0><code># Heading 1

## Heading 1-1
Content of heading 1-1.

More lines in heading 1-1.

## Heading 1-2
Content of heading 1-2.

More lines in heading 1-2.

## Heading 1-3
* https://example.net
    * email: someemail@example.net
    * address: 123 street name
* https://google.com
    * email: blahblah
* https://parsiya.net
* https://parsiya.io

# Heading 2

## Heading 2-1
Heading 2-1 content.
</code></pre><h2 id=level-one-heading-and-their-content>Level-One Heading and Their Content
<a class=header-link href=#level-one-heading-and-their-content><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>First, we need to get the headings and their content. Using the markdown parser for this purpose did not work. In the AST, the content of each heading is not a child of the heading, instead everything is a child of root. See below for a representation of AST using <a href=https://github.com/awalterschulze/gographviz target=_blank rel="noreferrer noopener">gographviz</a>.</p><p>Instead, I used regex. I am trash at regex but I somehow got this to work.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#719e07>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#2aa198>&#34;regexp&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>var</span> testData = <span style=color:#2aa198>`
</span></span></span><span style=display:flex><span><span style=color:#2aa198># Heading 1
</span></span></span><span style=display:flex><span><span style=color:#2aa198>... // removed
</span></span></span><span style=display:flex><span><span style=color:#2aa198>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	reStr <span style=color:#719e07>:=</span> <span style=color:#2aa198>&#34;(?m)^\\s*#{1}\\s*([^#\\n]+)$&#34;</span>
</span></span><span style=display:flex><span>	re <span style=color:#719e07>:=</span> regexp.<span style=color:#268bd2>MustCompile</span>(reStr)
</span></span><span style=display:flex><span>	result <span style=color:#719e07>:=</span> re.<span style=color:#268bd2>FindAllStringSubmatch</span>(testData, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> _, match <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> result {
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(match)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The result is a <code>[][]string</code>. Each <code>[]string</code> has two items, the first one is the complete line and the second is the match (just the heading). Run it in the Go playground at <a href=https://play.golang.org/p/09CPo4Cz32Z target=_blank rel="noreferrer noopener">https://play.golang.org/p/09CPo4Cz32Z</a> or see <code>regex.code</code> on Github.</p><pre tabindex=0><code>[
# Heading 1 Heading 1]
[
# Heading 2 Heading 2]
</code></pre><p>This only returns the headings, but we want all the content. By switching the regex method to <a href=https://golang.org/pkg/regexp/#Regexp.FindAllStringSubmatchIndex target=_blank rel="noreferrer noopener">FindAllStringSubmatchIndex</a>, we can get the index of these items.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	reStr <span style=color:#719e07>:=</span> <span style=color:#2aa198>&#34;(?m)^\\s*#{1}\\s*([^#\\n]+)$&#34;</span>
</span></span><span style=display:flex><span>	re <span style=color:#719e07>:=</span> regexp.<span style=color:#268bd2>MustCompile</span>(reStr)
</span></span><span style=display:flex><span>	result <span style=color:#719e07>:=</span> re.<span style=color:#268bd2>FindAllStringSubmatchIndex</span>(testData, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> _, match <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> result {
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(match)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run it in the Go playground: <a href=https://play.golang.org/p/jizwSQHTRG4 target=_blank rel="noreferrer noopener">https://play.golang.org/p/jizwSQHTRG4</a>.</p><pre tabindex=0><code>[0 12 3 12]
[338 350 341 350]
</code></pre><ul><li>Heading: Everything between <code>result[2]</code> and <code>result[3]</code>. In other words, <code>testData[result[2]:result[3]]</code>.</li><li>Content: Everything between the last number in one result and the first one in the next result (or until the end of the document if it's the last result).</li></ul><p>We can also do the same for level 2 headings. Just change the regex to <code>(?m)^\\s*#{2}\\s*([^#\\n]+)$</code> (the number of <code>#</code>s to look for). I ended up with the following function that can give me heading and content of every heading level.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// RawHeading represents a heading, raw content, and subheadings (if any).
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>type</span> RawHeading <span style=color:#268bd2>struct</span> {
</span></span><span style=display:flex><span>	Title   <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>	Content <span style=color:#dc322f>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Heading reads a markdown string and returns a slice of RawHeadings.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>Heading</span>(content <span style=color:#dc322f>string</span>, level <span style=color:#dc322f>int</span>) (fi []RawHeading, err <span style=color:#dc322f>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#719e07>defer</span> <span style=color:#268bd2>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> r <span style=color:#719e07>:=</span> <span style=color:#b58900>recover</span>(); r <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>			err = fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;panic in parse.Heading %v&#34;</span>, r)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> level &lt; <span style=color:#2aa198>1</span> {
</span></span><span style=display:flex><span>		level = <span style=color:#2aa198>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Split into different sections.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// TODO: Find better regex.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#586e75>// Narrator voice: This never happened.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	reStr <span style=color:#719e07>:=</span> fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;(?m)^\\s*#{%d}\\s*([^#\\n]+)$&#34;</span>, level)
</span></span><span style=display:flex><span>	re <span style=color:#719e07>:=</span> regexp.<span style=color:#268bd2>MustCompile</span>(reStr)
</span></span><span style=display:flex><span>	result <span style=color:#719e07>:=</span> re.<span style=color:#268bd2>FindAllStringSubmatchIndex</span>(content, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/*
</span></span></span><span style=display:flex><span><span style=color:#586e75>    Returns slices of four ints.
</span></span></span><span style=display:flex><span><span style=color:#586e75>    First two are the complete heading, including the #.
</span></span></span><span style=display:flex><span><span style=color:#586e75>    Last two are only the heading name.
</span></span></span><span style=display:flex><span><span style=color:#586e75>    The rest of the heading will be from the last number of one to start of the next.
</span></span></span><span style=display:flex><span><span style=color:#586e75>    I will forget how this works, but it works. Don&#39;t touch it future Parsia.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	*/</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> result {
</span></span><span style=display:flex><span>		<span style=color:#268bd2>var</span> raw RawHeading
</span></span><span style=display:flex><span>		section <span style=color:#719e07>:=</span> result[i]
</span></span><span style=display:flex><span>		headingTextStart <span style=color:#719e07>:=</span> section[<span style=color:#2aa198>2</span>]
</span></span><span style=display:flex><span>		headingTextEnd <span style=color:#719e07>:=</span> section[<span style=color:#2aa198>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		raw.Title = content[headingTextStart:headingTextEnd]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#268bd2>var</span> startOfNextHeading <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>		<span style=color:#586e75>// Check for last item, last item continues to the end.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>if</span> i <span style=color:#719e07>==</span> <span style=color:#b58900>len</span>(result)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span> {
</span></span><span style=display:flex><span>			startOfNextHeading = <span style=color:#b58900>len</span>(content) <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>
</span></span><span style=display:flex><span>		} <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>			startOfNextHeading = result[i<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>][<span style=color:#2aa198>0</span>]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#586e75>// Trim whitespace from start and ending of content.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		raw.Content = strings.<span style=color:#268bd2>TrimSpace</span>(content[section[<span style=color:#2aa198>3</span>]:startOfNextHeading])
</span></span><span style=display:flex><span>		fi = <span style=color:#b58900>append</span>(fi, raw)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> fi, <span style=color:#cb4b16>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note the name of the package. It might not make sense in the <code>main</code> but all these functions are part of a package <code>parse</code>. When using them outside, we call <code>parse.Heading(...)</code> which sounds nice. For more information on package naming conventions, please read this Golang.org blog post: <a href=https://blog.golang.org/package-names target=_blank rel="noreferrer noopener">https://blog.golang.org/package-names</a>.</p><p>Running it gives us what we want: <a href=https://play.golang.org/p/YncrOEfiBxC target=_blank rel="noreferrer noopener">https://play.golang.org/p/YncrOEfiBxC</a>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	levelOnes, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>Heading</span>(testData, <span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> _, l1 <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> levelOnes {
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(l1.Title)
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(l1.Content)
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;--------------------&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the result:</p><pre tabindex=0><code>Heading 1
## Heading 1-1
Content of heading 1-1.

More lines in heading 1-1.

## Heading 1-2
Content of heading 1-2.

More lines in heading 1-2.

## Heading 1-3
* https://example.net
    * email: someemail@example.net
    * address: 123 street name
* https://google.com
    * email: blahblah
* https://parsiya.net
* https://parsiya.io
--------------------
Heading 2
## Heading 2-1
Heading 2-1 content.
--------------------
</code></pre><p>This function also works for sub-headings, meaning we can pass <code>.Content</code> of level-ones to get level-twos: <a href=https://play.golang.org/p/ugfY0D_nEWT target=_blank rel="noreferrer noopener">https://play.golang.org/p/ugfY0D_nEWT</a> or <code>heading.go</code> on Github.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	levelOnes, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>Heading</span>(testData, <span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> _, l1 <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> levelOnes {
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;Level 1 title:&#34;</span>, l1.Title)
</span></span><span style=display:flex><span>		levelTwos, _ <span style=color:#719e07>:=</span> <span style=color:#268bd2>Heading</span>(l1.Content, <span style=color:#2aa198>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> _, l2 <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> levelTwos {
</span></span><span style=display:flex><span>			fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;Level 2 title:&#34;</span>, l2.Title)
</span></span><span style=display:flex><span>			fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;Level 2 content:&#34;</span>, l2.Content)
</span></span><span style=display:flex><span>			fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;********************&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;--------------------&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Result:</p><pre tabindex=0><code>Level 1 title: Heading 1
Level 2 title: Heading 1-1
Level 2 content: Content of heading 1-1.

More lines in heading 1-1.
********************
Level 2 title: Heading 1-2
Level 2 content: Content of heading 1-2.

More lines in heading 1-2.
********************
Level 2 title: Heading 1-3
Level 2 content: * https://example.net
    * email: someemail@example.net
    * address: 123 street name
* https://google.com
    * email: blahblah
* https://parsiya.net
* http://parsiya.i
********************
--------------------
Level 1 title: Heading 2
Level 2 title: Heading 2-1
Level 2 content: Heading 2-1 content
********************
--------------------
</code></pre><p><strong>Problem (somewhat) solved.</strong></p><h2 id=markdown-to-html-with-blackfriday>Markdown to HTML with Blackfriday
<a class=header-link href=#markdown-to-html-with-blackfriday><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>This was perhaps the easiest part of the task. Most content in that file is either used as plaintext or passed directly to Blackfriday for parsing to HTML. When importing blackfriday, be sure to use version 2.0. You can either use the new Go modules or use the pinned package at <a href=https://gopkg.in/russross/blackfriday.v2 target=_blank rel="noreferrer noopener">https://gopkg.in/russross/blackfriday.v2</a>.</p><p>To generate HTML, use <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Run target=_blank rel="noreferrer noopener">Run</a>. Pass the text as a byte slice, indicate what kind of extensions to use (or pass nothing for a set of standard extensions), and get the HTML bytes.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>mdBytes <span style=color:#719e07>:=</span> blackfriday.<span style=color:#268bd2>Run</span>([]<span style=color:#b58900>byte</span>(input), blackfriday.<span style=color:#268bd2>WithNoExtensions</span>())
</span></span><span style=display:flex><span>mdStr <span style=color:#719e07>:=</span> <span style=color:#b58900>string</span>(mdBytes)
</span></span></code></pre></div><p>We also want to remove the <code>&lt;p></code> and <code>&lt;/p></code> tags from the result. It can be done with a <a href=https://golang.org/pkg/strings/#Replacer.Replace%5c target=_blank rel="noreferrer noopener">strings.Replacer</a>. Pass strings in pairs where first one is the match and next is the replacement. In this code snippet, we are replacing both tags with nothing (i.e. removing them). Then call <a href=https://golang.org/pkg/strings/#Replacer.Replace target=_blank rel="noreferrer noopener">Replacer.Replace</a>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>removePTags <span style=color:#719e07>:=</span> strings.<span style=color:#268bd2>NewReplacer</span>(<span style=color:#2aa198>&#34;&lt;p&gt;&#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#2aa198>&#34;&lt;/p&gt;&#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>)
</span></span><span style=display:flex><span>out <span style=color:#719e07>:=</span> removePTags.<span style=color:#268bd2>Replace</span>(md)
</span></span></code></pre></div><p>The final <code>RichText</code> function looks like this. Call it with <code>parse.RichText</code>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// RichText returns a string with the formatted rich text section.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>RichText</span>(input <span style=color:#dc322f>string</span>) <span style=color:#dc322f>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Richtext content can be passed to markdown safely.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	md <span style=color:#719e07>:=</span> <span style=color:#b58900>string</span>(blackfriday.<span style=color:#268bd2>Run</span>([]<span style=color:#b58900>byte</span>(input), blackfriday.<span style=color:#268bd2>WithNoExtensions</span>()))
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Remove &lt;p&gt; and &lt;/p&gt;.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	removePTags <span style=color:#719e07>:=</span> strings.<span style=color:#268bd2>NewReplacer</span>(<span style=color:#2aa198>&#34;&lt;p&gt;&#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#2aa198>&#34;&lt;/p&gt;&#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	out <span style=color:#719e07>:=</span> removePTags.<span style=color:#268bd2>Replace</span>(md)
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Trim whitespace.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>return</span> strings.<span style=color:#268bd2>TrimSpace</span>(out)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which results in (reproduce it by running <code>richtext.go</code>):</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>$ go run richtext.go
</span></span><span style=display:flex><span>This is line one.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>This is line two.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>This is a list:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#268bd2>ul</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#268bd2>li</span>&gt;item1&lt;/<span style=color:#268bd2>li</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#268bd2>li</span>&gt;item2&lt;/<span style=color:#268bd2>li</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#268bd2>ul</span>&gt;
</span></span></code></pre></div><h2 id=blackfridays-markdown-ast>Blackfriday's Markdown AST
<a class=header-link href=#blackfridays-markdown-ast><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>In this section, we will learn how to use the parser and then visualize the resulting AST.</p><p>Here's a quick start:</p><ol><li>Use the <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#New target=_blank rel="noreferrer noopener">New</a> function to get a <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Markdown target=_blank rel="noreferrer noopener">*Markdown</a> pointer. Pass options for markdown extensions to <code>New</code> or nothing for a standard set.</li><li>Use the <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Markdown.Parse target=_blank rel="noreferrer noopener">Parse</a> method on the <code>*Markdown</code> to get a <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Node target=_blank rel="noreferrer noopener">*Node</a>.<ul><li>This node points to the root of the AST. This root node will always be of <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#NodeType target=_blank rel="noreferrer noopener">NodeType</a> <code>Document</code>.</li></ul></li><li>Use the <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Node.Walk target=_blank rel="noreferrer noopener">Walk</a> on a <code>Node</code> to traverse the sub-tree under that node. This can be used for any node.</li><li>This method has a callback function of type <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#NodeVisitor target=_blank rel="noreferrer noopener">NodeVisitor</a> or <code>type NodeVisitor func(node *Node, entering bool) WalkStatus</code>.</li></ol><h3 id=nodevisitor>NodeVisitor
<a class=header-link href=#nodevisitor><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Most of the parsing logic happens inside the callback function.</p><ul><li>It is called twice for every node, one when first visiting it with <code>entering == true</code> and the other when leaving after all its children are visited with <code>entering == false</code>.<ul><li>Useful when you want to gather information about all children of a node.</li></ul></li><li><code>NodeVisitor</code> can be an in-line or anonymous function. This allows us to use the parent function variables.</li><li>The return value of <code>NodeVisitor</code> is of type <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#WalkStatus target=_blank rel="noreferrer noopener">WalkStatus</a>. We can use it to control the parser.<ul><li><code>GotoNext</code> = Default, go to next node.</li><li><code>SkipChildren</code> = Skip all children of current node.</li><li><code>Terminate</code> = Terminate the traversal.</li></ul></li><li>Depending on <code>NodeType</code> some extra <a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Node target=_blank rel="noreferrer noopener">struct fields</a> (e.g. <code>HeadingData</code>) might be populated. The text content of every node (if any) is stored in <code>Literal</code>.</li></ul><h3 id=print-everything>Print Everything
<a class=header-link href=#print-everything><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Let's do some parsing on our test data to see how the AST looks like (see <code>parse-print.go</code>):</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// PrintNode returns a string representation of the node.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>PrintNode</span>(n <span style=color:#719e07>*</span>blackfriday.Node) <span style=color:#dc322f>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> sb strings.Builder
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Type: %v - &#34;</span>, n.Type))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Title: %v - &#34;</span>, n.Title))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Parent: %v - &#34;</span>, n.Parent))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Literal: %v&#34;</span>, <span style=color:#b58900>string</span>(n.Literal)))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#2aa198>&#34;\n--------------------&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> sb.<span style=color:#268bd2>String</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><span class=caption-wrapper><img class=caption src=01.png title="Output of parse-print.go" alt="Output of parse-print.go">
<span class=caption-text>Output of parse-print.go</span></span><p>It might have been easier to just print the node as a JSON string. But each node contains a lot of children and I got a stack overflow (as in literally).</p><h3 id=ast-visualization-with-gographviz>AST Visualization with gographviz
<a class=header-link href=#ast-visualization-with-gographviz><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Text does not really help. Getting a visualization of the AST helps a lot more. There are probably better ways of doing it (I did not like using the global variable <code>counter</code>) but it works and was reasonably simple to figure out in 30 minutes or so. <a href=https://github.com/awalterschulze/gographviz target=_blank rel="noreferrer noopener">gographviz</a> creates graphs for us and then returns the <code>dot</code> file. These are text files that can be passed to any number of implementations (including web services) to generate pictures (e.g. svg, png, etc.).</p><p>The magic is in <code>viz.go</code>. At each node we:</p><ol><li>Create a unique ID for this node using <code>counter</code>.</li><li>Add the node's type and the first 16 chars of text (if any) to the label.<ul><li>If added, <code>label</code> attribute is displayed in the node, otherwise ID will be used.</li><li>We can add new lines to labels in by adding <code>\n</code> to the string and enclosing them in double quotes. See <code>Label</code> function.</li><li><a href=https://godoc.org/gopkg.in/russross/blackfriday.v2#Node.String target=_blank rel="noreferrer noopener">Node.String()</a> returns the first 16 chars of <code>Literal</code>.</li></ul></li><li>Add the node to the graph with the label and ID.</li><li>If the node is not root (root's parent ID is passed with <code>""</code>), add an edge from its parent to the node.</li><li>Increase counter.</li><li>Do the same for every child of the node (see <code>for</code> in code).</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>var</span> counter = <span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Viz adds a node to the graph and adds an edge to its parent.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>Viz</span>(graph <span style=color:#719e07>*</span>gographviz.Graph, graphName, parentID <span style=color:#dc322f>string</span>, node <span style=color:#719e07>*</span>blackfriday.Node) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	myID <span style=color:#719e07>:=</span> strconv.<span style=color:#268bd2>Itoa</span>(counter)
</span></span><span style=display:flex><span>	attrs <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]<span style=color:#dc322f>string</span>)
</span></span><span style=display:flex><span>	attrs[<span style=color:#b58900>string</span>(gographviz.Label)] = <span style=color:#268bd2>Label</span>(node)
</span></span><span style=display:flex><span>	graph.<span style=color:#268bd2>AddNode</span>(graphName, myID, attrs)
</span></span><span style=display:flex><span>	<span style=color:#586e75>// If not root, add an edge to parent.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#586e75>// TODO: How can we eliminate this check to speed things up?
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>if</span> parentID <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		graph.<span style=color:#268bd2>AddEdge</span>(parentID, myID, <span style=color:#cb4b16>true</span>, <span style=color:#cb4b16>nil</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Increase counter.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	counter<span style=color:#719e07>++</span>
</span></span><span style=display:flex><span>	child <span style=color:#719e07>:=</span> node.FirstChild
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> child <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#268bd2>Viz</span>(graph, graphName, myID, child)
</span></span><span style=display:flex><span>		child = child.Next
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Label returns a label for the node. Label is &#34;Node.Type\n\Node.String()&#34;.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>Label</span>(node <span style=color:#719e07>*</span>blackfriday.Node) <span style=color:#dc322f>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> sb strings.Builder
</span></span><span style=display:flex><span>	<span style=color:#586e75>// We might need to add a new line to label, so we need to enclose the
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#586e75>// label in double-quotes.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#2aa198>&#34;\&#34;&#34;</span>)
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(node.Type.<span style=color:#268bd2>String</span>())
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(node.Literal) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>		sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#2aa198>&#34;\\n&#34;</span> <span style=color:#719e07>+</span> node.<span style=color:#268bd2>String</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#2aa198>&#34;\&#34;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> sb.<span style=color:#268bd2>String</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run <code>viz-ast.go</code> to get the <code>graph.dot</code> file, then generate the graph. Here's a 210KB copy (<strong>open in new tab and zoom, it's around 3500*800 pixels</strong>):</p><span class=caption-wrapper><img class=caption src=03.png title="testData AST" alt="testData AST">
<span class=caption-text>testData AST</span></span><p>The Github repository also contains a 30KB <code>svg</code> version. As I mentioned above, most items are children of root.</p><h3 id=a-closer-look-at-headings>A Closer Look at Headings
<a class=header-link href=#a-closer-look-at-headings><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Let's do a bit more and look at headings. To make our life easier, we expand our package with some helper functions. We already know heading's title (if any) is its first and only child. There's an edge case, not every heading has a title.</p><span class=caption-wrapper><img class=caption src=04.png title="Headings in AST" alt="Headings in AST">
<span class=caption-text>Headings in AST</span></span><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>// IsHeading returns true if node is type heading.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>IsHeading</span>(n <span style=color:#719e07>*</span>blackfriday.Node) <span style=color:#dc322f>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> n.Type <span style=color:#719e07>==</span> blackfriday.Heading
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// HeadingTitle returns the title of the heading by returning the Literal of its
</span></span></span><span style=display:flex><span><span style=color:#586e75>// first child.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>HeadingTitle</span>(n <span style=color:#719e07>*</span>blackfriday.Node) <span style=color:#dc322f>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#586e75>// Check if it has a child and its of type Text. Headings might not have titles.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>if</span> n.FirstChild <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> <span style=color:#719e07>&amp;&amp;</span> n.FirstChild.Type <span style=color:#719e07>==</span> blackfriday.Text {
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> <span style=color:#b58900>string</span>(n.FirstChild.Literal)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#586e75>// This is not exactly idiomatic because successful return value should be
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#586e75>// the last return. However, this looks clearer.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// PrintHeading returns the information of a Heading node.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>PrintHeading</span>(n <span style=color:#719e07>*</span>blackfriday.Node) <span style=color:#dc322f>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> sb strings.Builder
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Heading Title: %s - &#34;</span>, <span style=color:#268bd2>HeadingTitle</span>(n)))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Heading Level: %d - &#34;</span>, n.HeadingData.Level))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Heading HeadingID: %s - &#34;</span>, n.HeadingData.HeadingID))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;Heading IsTitleBlock: %v&#34;</span>, n.HeadingData.IsTitleblock))
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#2aa198>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	sb.<span style=color:#268bd2>WriteString</span>(<span style=color:#268bd2>PrintNode</span>(n))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> sb.<span style=color:#268bd2>String</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I am passing the responsibility of checking the node type to the caller. Next, we modify the anonymous <code>NodeVisitor</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	md <span style=color:#719e07>:=</span> blackfriday.<span style=color:#268bd2>New</span>(blackfriday.<span style=color:#268bd2>WithNoExtensions</span>())
</span></span><span style=display:flex><span>	rootNode <span style=color:#719e07>:=</span> md.<span style=color:#268bd2>Parse</span>([]<span style=color:#b58900>byte</span>(testData))
</span></span><span style=display:flex><span>	<span style=color:#586e75>// rootNode is always of NodeType &#34;Document&#34; or 0.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>	rootNode.<span style=color:#268bd2>Walk</span>(<span style=color:#268bd2>func</span>(node <span style=color:#719e07>*</span>blackfriday.Node, entering <span style=color:#dc322f>bool</span>) blackfriday.WalkStatus {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> parse.<span style=color:#268bd2>IsHeading</span>(node) {
</span></span><span style=display:flex><span>			fmt.<span style=color:#268bd2>Println</span>(parse.<span style=color:#268bd2>PrintHeading</span>(node))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> blackfriday.GoToNext
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally run <code>parse-print-heading.go</code> to see heading levels and titles:</p><span class=caption-wrapper><img class=caption src=02.png title="Output of parse-print-heading.go" alt="Output of parse-print-heading.go">
<span class=caption-text>Output of parse-print-heading.go</span></span><h3 id=a-closer-look-at-lists>A Closer Look at Lists
<a class=header-link href=#a-closer-look-at-lists><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Armed with our knowledge of markdown parser, we can move on to lists. To just visualize the list:</p><ol><li>Traverse the tree until we get to a node of type <code>List</code> with a parent of type <code>Document</code>.</li><li>Pass the node to <code>parse.Viz</code>.</li><li>Cancel walk by return <code>blackfriday.Terminate</code>. This works for this document where we only have one list, in a document with multiple top-level lists, we must return <code>blackfriday.SkipChildren</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
</span></span><span style=display:flex><span>	md <span style=color:#719e07>:=</span> blackfriday.<span style=color:#268bd2>New</span>(blackfriday.<span style=color:#268bd2>WithNoExtensions</span>())
</span></span><span style=display:flex><span>	rootNode <span style=color:#719e07>:=</span> md.<span style=color:#268bd2>Parse</span>([]<span style=color:#b58900>byte</span>(testData))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	g <span style=color:#719e07>:=</span> gographviz.<span style=color:#268bd2>NewGraph</span>()
</span></span><span style=display:flex><span>	g.<span style=color:#268bd2>SetName</span>(<span style=color:#2aa198>&#34;list&#34;</span>)
</span></span><span style=display:flex><span>	g.<span style=color:#268bd2>SetDir</span>(<span style=color:#cb4b16>true</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	rootNode.<span style=color:#268bd2>Walk</span>(<span style=color:#268bd2>func</span>(node <span style=color:#719e07>*</span>blackfriday.Node, entering <span style=color:#dc322f>bool</span>) blackfriday.WalkStatus {
</span></span><span style=display:flex><span>		<span style=color:#586e75>// Check if node has a parent, otherwise we will panic when we check
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#586e75>// the panret type.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>if</span> node.Parent <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> node.Type <span style=color:#719e07>==</span> blackfriday.List <span style=color:#719e07>&amp;&amp;</span> node.Parent.Type <span style=color:#719e07>==</span> blackfriday.Document {
</span></span><span style=display:flex><span>				parse.<span style=color:#268bd2>Viz</span>(g, <span style=color:#2aa198>&#34;list&#34;</span>, <span style=color:#2aa198>&#34;&#34;</span>, node)
</span></span><span style=display:flex><span>				<span style=color:#719e07>return</span> blackfriday.Terminate
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> blackfriday.GoToNext
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	fi, err <span style=color:#719e07>:=</span> os.<span style=color:#268bd2>Create</span>(<span style=color:#2aa198>&#34;graph-list.dot&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#b58900>panic</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>defer</span> fi.<span style=color:#268bd2>Close</span>()
</span></span><span style=display:flex><span>	fi.<span style=color:#268bd2>WriteString</span>(g.<span style=color:#268bd2>String</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run <code>viz-list.go</code> to generate <code>graph-list.dot</code> of the following list:</p><pre tabindex=0><code>* https://example.net
    * email: someemail@example.net
    * address: 123 street name
* https://google.com
    * email: blahblah
* https://parsiya.net
* https://parsiya.io
</code></pre><span class=caption-wrapper><img class=caption src=05.png title="List in AST (open in new tab for full size image" alt="List in AST (open in new tab for full size image">
<span class=caption-text>List in AST (open in new tab for full size image</span></span><h1 id=conclusion>Conclusion
<a class=header-link href=#conclusion><svg class="fill-current o-60 hover-accent-color-light" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>We learned quite a few tricks. Learned how to use Blackfriday's markdown parser and how to generate graphs. The graph generation from AST is pretty cool and I am sure will come handy later on.</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Parsia</span></span>
<time>Oct 28, 2018</time>
<span class=categories>Tags:
<a class=category href=https://parsiya.net/tags/blackfriday>Blackfriday</a> <a class=category href=https://parsiya.net/tags/markdown>Markdown</a></span></p><p class=meta><a class="basic-alignment left" href=https://parsiya.net/blog/2018-10-26-def-con-26-tineola-youtube-video/ title="DEF CON 26 - Tineola - Youtube Video">DEF CON 26 - Tineola - Youtube Video</a>
<a class="basic-alignment right" href=https://parsiya.net/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/ title="Windows Filetime Timestamps and Byte Wrangling with Go">Windows Filetime Timestamps and Byte Wrangling with Go</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//parsiya.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I?</h1><p><p>I am Parsia, an application security engineer.</p><p>I write about application security, cryptography, static analysis, and
(of course) videogames.</p><p>Click on <a href=/about/>About Me!</a> to know more.</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="me noopener noreferrer" href=https://infosec.exchange/@parsiya title=https://infosec.exchange/@parsiya><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://github.com/parsiya/ title=https://github.com/parsiya/><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://twitter.com/cryptogangsta/ title=https://twitter.com/cryptogangsta/><i class="fa fa-twitter fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/parsiya title=https://www.linkedin.com/in/parsiya><i class="fa fa-linkedin fa-3x"></i></a></li></ul><section class=odd><h1>Collections</h1><li><a href=https://parsiya.net/categories/thick-client-proxying/ title="Thick Client Proxying">Thick Client Proxying</a></li><li><a href=https://parsiya.net/categories/writeup/ title=CTFs/Writeups>CTFs/Writeups</a></li><li><a href=https://parsiya.net/categories/attack-surface-analysis/ title="Attack Surface Analysis">Attack Surface Analysis</a></li><li><a href=https://parsiya.net/categories/semgrep/ title=Semgrep>Semgrep</a></li><li><a href=https://parsiya.net/categories/bug-bounty/ title="Bug Bounty">Bug Bounty</a></li><li><a href=https://parsiya.net/categories/blockchain/ title="Blockchain (lol)">Blockchain (lol)</a></li><li><a href=https://parsiya.net/categories/crypto/ title=Crypto(graphy)>Crypto(graphy)</a></li><li><a href=https://parsiya.net/categories/burp-extension/ title="Burp Extension Development">Burp Extension Development</a></li><li><a href=https://parsiya.net/categories/automation/ title=Automation>Automation</a></li><li><a href=https://parsiya.net/categories/reverse-engineering/ title="Reverse Engineering">Reverse Engineering</a></li><li><a href=https://parsiya.net/categories/winappdbg/ title="WinAppDbg (use Frida instead)">WinAppDbg (use Frida instead)</a></li><li><a href=https://awsome.pw title='AWSome.pw - S3 bucket squatting - my very "legit" branded vulnerability'>AWSome.pw - S3 bucket squatting - my very "legit" branded vulnerability</a></li></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2024 Parsia - <a href=https://parsiya.net/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>