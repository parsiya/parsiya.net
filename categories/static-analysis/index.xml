<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Static Analysis on Hackerman's Hacking Tutorials</title><link>https://parsiya.net/categories/static-analysis/</link><description>Recent content in Static Analysis on Hackerman's Hacking Tutorials</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 11 Dec 2025 19:00:00 -0700</lastBuildDate><atom:link href="https://parsiya.net/categories/static-analysis/index.xml" rel="self" type="application/rss+xml"/><item><title>AI-Native SARIF</title><link>https://parsiya.net/blog/ai-native-sarif/</link><pubDate>Thu, 11 Dec 2025 19:00:00 -0700</pubDate><guid>https://parsiya.net/blog/ai-native-sarif/</guid><description>&lt;p&gt;The &amp;quot;radical&amp;quot; idea to add prompts and code context directly into SARIF files for
AI triage.&lt;/p&gt;</description></item><item><title>WTF is ... - AI-Native SAST?</title><link>https://parsiya.net/blog/wtf-is-ai-native-sast/</link><pubDate>Fri, 31 Oct 2025 01:00:00 -0700</pubDate><guid>https://parsiya.net/blog/wtf-is-ai-native-sast/</guid><description>&lt;p&gt;Ladies and gentlemen, my name is Parsia and I'm here to ask and answer one
simple question: WTF is AI-Native SAST? (RIP TotalBiscuit).&lt;/p&gt;
&lt;p&gt;Spoiler: It's SAST+AI. But that doesn't make it useless. Quite the opposite,
I'll make the case for passing all your code to AI while tokens are cheap. Don't
believe the marketing, though. Current LLMs need serious hand-holding to go
beyond surface-level bug discovery, and that hand-holding comes from static
analysis.&lt;/p&gt;</description></item><item><title>Knee Deep in tree-sitter CST</title><link>https://parsiya.net/blog/knee-deep-tree-sitter-2/</link><pubDate>Tue, 09 Apr 2024 12:35:35 -0800</pubDate><guid>https://parsiya.net/blog/knee-deep-tree-sitter-2/</guid><description>&lt;p&gt;We will continue the tree-sitter adventure and tackle the problems we couldn't
solve with just tree-sitter queries. We can get results with a combination of
queries and the Concrete Syntax Tree (CST).&lt;/p&gt;
&lt;p&gt;In the






 
 
 


 
&lt;a href="https://parsiya.net/blog/knee-deep-tree-sitter-queries/" title="previous post" rel="nofollow" target="_blank"&gt;previous post&lt;/a&gt;
, I focused on just using queries. While they're useful for finding specific nodes, they're not enough.&lt;/p&gt;
&lt;p&gt;Code is at &lt;a href="https://github.com/parsiya/knee-deep-tree-sitter" target="_blank" rel="noreferrer noopener"&gt;https://github.com/parsiya/knee-deep-tree-sitter&lt;/a&gt;. Don't forget to
populate the submodule, we need it for the last part.&lt;/p&gt;</description></item><item><title>Knee Deep in tree-sitter Queries</title><link>https://parsiya.net/blog/knee-deep-tree-sitter-queries/</link><pubDate>Tue, 19 Mar 2024 16:35:30 -0700</pubDate><guid>https://parsiya.net/blog/knee-deep-tree-sitter-queries/</guid><description>&lt;p&gt;&lt;a href="https://tree-sitter.github.io/tree-sitter/" target="_blank" rel="noreferrer noopener"&gt;tree-sitter&lt;/a&gt; is a parser generator. You can use it to parse source code which
is the first step of static analysis. For example, GitHub uses it to highlight
code, code navigation, and also in CodeQL extractors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: Queries are great for capturing text from code. But to extract
anything moderately structured we need to traverse the syntax tree.&lt;/p&gt;
&lt;p&gt;And, yes, the title is based on Doom Episode 1 &lt;a href="https://doom.fandom.com/wiki/Knee-Deep_in_the_Dead" target="_blank" rel="noreferrer noopener"&gt;Knee Deep in the Dead&lt;/a&gt;.
I love the title (and the game), because it lets me relive my edgy days.&lt;/p&gt;</description></item><item><title>A Few Fun Semgrep Experiments</title><link>https://parsiya.net/blog/semgrep-fun/</link><pubDate>Sun, 21 Jan 2024 02:32:24 -0800</pubDate><guid>https://parsiya.net/blog/semgrep-fun/</guid><description>&lt;p&gt;I want to use Semgrep as a light code intelligence tool with a few experiments.
I will write custom rules to extract info from code and then process the
results.&lt;/p&gt;
&lt;p&gt;The type of these experiments is inspired by &lt;a href="https://github.com/mjambon" target="_blank" rel="noreferrer noopener"&gt;Martin Jambon&lt;/a&gt; who is
actually a core Semgrep developer. These are supposed to be self-contained but
short experiments. You can see his at &lt;a href="https://github.com/mjambon/dev-random" target="_blank" rel="noreferrer noopener"&gt;https://github.com/mjambon/dev-random&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Semgrep's Experimental Rule Syntax</title><link>https://parsiya.net/blog/2023-10-28-semgreps-experimental-rule-syntax/</link><pubDate>Sat, 28 Oct 2023 12:43:08 -0700</pubDate><guid>https://parsiya.net/blog/2023-10-28-semgreps-experimental-rule-syntax/</guid><description>&lt;p&gt;Semgrep has an experimental and (IMO) more readable rule syntax. I am converting
my own reference into a tutorial.&lt;/p&gt;</description></item><item><title>Code Review Hot Spots with Semgrep</title><link>https://parsiya.net/blog/2022-04-07-code-review-hot-spots-with-semgrep/</link><pubDate>Thu, 07 Apr 2022 12:51:57 -0700</pubDate><guid>https://parsiya.net/blog/2022-04-07-code-review-hot-spots-with-semgrep/</guid><description>&lt;p&gt;I will discuss the (not novel) concept of code review hot spots. Hot spots are
parts of the code that might contain vulnerabilities. They are not suitable for
automatic reporting, so security engineers should review them manually. I will
define what I call a hot spot; I'll find some examples with Semgrep; and finally,
I'll show how I collect these rules.&lt;/p&gt;</description></item><item><title>A Hands-On Intro to Semgrep's Autofix</title><link>https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/</link><pubDate>Mon, 25 Oct 2021 20:00:47 -0700</pubDate><guid>https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/</guid><description>&lt;p&gt;Semgrep's experimental &lt;a href="https://semgrep.dev/docs/experiments/overview/#autofix" target="_blank" rel="noreferrer noopener"&gt;autofix&lt;/a&gt; feature can automagically
modify vulnerable code. A few things can be fixed like this but it's worth
exploring. This post is an introduction to creating fixes for your Semgrep
rules.&lt;/p&gt;
&lt;p&gt;I have included links to the playground for practicing. If you prefer
running the rules via the command-line please see the rules and code at
&lt;a href="https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix" target="_blank" rel="noreferrer noopener"&gt;https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Semgrep: The Surgical Static Analysis Tool</title><link>https://parsiya.net/blog/2021-06-22-semgrep-the-surgical-static-analysis-tool/</link><pubDate>Tue, 22 Jun 2021 18:42:06 -0700</pubDate><guid>https://parsiya.net/blog/2021-06-22-semgrep-the-surgical-static-analysis-tool/</guid><description>&lt;h1 id="why-are-we-here"&gt;Why are We Here?
&lt;a class="header-link" href="#why-are-we-here"&gt;&lt;svg class="fill-current o-60 hover-accent-color-light" height="22px" viewBox="0 0 24 24" width="22px" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M0 0h24v24H0z" fill="none"/&gt;&lt;path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/&gt;&lt;/svg&gt;&lt;/a&gt;
&lt;/h1&gt;&lt;p&gt;What this blog is about:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why I like Semgrep.&lt;/li&gt;
&lt;li&gt;Why I think you should use it.&lt;/li&gt;
&lt;li&gt;How I use Semgrep.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What this blog is not about:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What static analysis is.&lt;/li&gt;
&lt;li&gt;Semgrep tutorial.&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>