<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Hackerman's Hacking Tutorials</title><link>https://parsiya.net/categories/go/</link><description>Recent content in Go on Hackerman's Hacking Tutorials</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 May 2020 22:37:21 -0700</lastBuildDate><atom:link href="https://parsiya.net/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Slices and Their Oddities</title><link>https://parsiya.net/blog/2020-05-17-go-slices-and-their-oddities/</link><pubDate>Sun, 17 May 2020 22:37:21 -0700</pubDate><guid>https://parsiya.net/blog/2020-05-17-go-slices-and-their-oddities/</guid><description>&lt;p>A friend pointed me to this &lt;a href="https://medium.com/@gotzmann/so-you-think-you-know-go-c5164b0d0511" target="_blank" rel="noreferrer noopener">Go quiz about slices&lt;/a> by
&lt;a href="https://github.com/gotzmann" target="_blank" rel="noreferrer noopener">Serge Gotsuliak&lt;/a>. It's an interesting exercise and points out the
intricacies of Go slices. I decided to explore it in detail. These oddities
might have security implications.&lt;/p></description></item><item><title>The Golang int and the Overlooked Bug</title><link>https://parsiya.net/blog/2020-04-05-the-golang-int-and-the-overlooked-bug/</link><pubDate>Sun, 05 Apr 2020 01:19:36 -0700</pubDate><guid>https://parsiya.net/blog/2020-04-05-the-golang-int-and-the-overlooked-bug/</guid><description>&lt;p>This blog is about a &lt;a href="https://securitylab.github.com/" target="_blank" rel="noreferrer noopener">GitHub Security Lab&lt;/a> &lt;code>Spot The Bug&lt;/code>
challenge that had an overlooked bug. &lt;a href="https://twitter.com/GHSecurityLab" target="_blank" rel="noreferrer noopener">Github Security Lab's Twitter account&lt;/a>
tweets code snippets from time to time. The challenge is to spot the bug.&lt;/p>
&lt;p>&lt;strong>Disclosure&lt;/strong>: I might be completely wrong because we only have access to the
snippet in the picture and people at the GitHub Security Lab are better than me
in static analysis.&lt;/p></description></item><item><title>path.Join Considered Harmful</title><link>https://parsiya.net/blog/2019-03-09-path.join-considered-harmful/</link><pubDate>Sat, 09 Mar 2019 20:43:40 -0500</pubDate><guid>https://parsiya.net/blog/2019-03-09-path.join-considered-harmful/</guid><description>&lt;p>Credit goes to my friend &lt;a href="https://www.linkedin.com/in/stark-riedesel-4162b846" target="_blank" rel="noreferrer noopener">Stark Riedesel&lt;/a>. Check out his &lt;a href="https://github.com/starkriedesel/" target="_blank" rel="noreferrer noopener">github profile&lt;/a>. One of these days I will bully him into reviving his blog.&lt;/p>
&lt;p>TL;DR: Instead of &lt;a href="https://golang.org/pkg/path/#Join" target="_blank" rel="noreferrer noopener">path.join&lt;/a> use &lt;a href="https://golang.org/pkg/path/filepath/" target="_blank" rel="noreferrer noopener">filepath.Join&lt;/a>.&lt;/p></description></item><item><title>AES-CFB128: PyCrypto vs. Go</title><link>https://parsiya.net/blog/2018-12-22-aes-cfb128-pycrypto-vs.-go/</link><pubDate>Sat, 22 Dec 2018 19:25:10 -0500</pubDate><guid>https://parsiya.net/blog/2018-12-22-aes-cfb128-pycrypto-vs.-go/</guid><description>&lt;p>We have encrypted something with AES-CFB128 in Go. How can we decrypt it with PyCrypto?&lt;/p>
&lt;p>This was originally part of the next blog post (about creating Python Burp extensions) but it grew large enough to be a separate post.&lt;/p>
&lt;p>Disclaimer: I am not knowledgeable enough to explain cryptography to people. Read actual papers/books/articles to figure things out. If you find mistakes here, please let me know.&lt;/p>
&lt;p>Code is at: &lt;a href="https://github.com/parsiya/Go-Security/tree/master/aes-cfb128" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/tree/master/aes-cfb128&lt;/a>&lt;/p></description></item><item><title>Pointers Inside for</title><link>https://parsiya.net/blog/2018-11-18-pointers-inside-for/</link><pubDate>Sun, 18 Nov 2018 16:57:24 -0500</pubDate><guid>https://parsiya.net/blog/2018-11-18-pointers-inside-for/</guid><description>&lt;p>Do not directly assign the for counter/range variables to a slice as pointers. Read this by Jon Calhoun &lt;a href="https://www.calhoun.io/gotchas-and-common-mistakes-with-closures-in-go/#variables-declared-in-for-loops-are-passed-by-reference" target="_blank" rel="noreferrer noopener">Variables declared in for loops are passed by reference&lt;/a>. &amp;quot;[...] the variables aren't being redeclared with each iteration [...]&amp;quot;.&lt;/p>
&lt;p>I have written so much buggy code that I am going to write this down.&lt;/p></description></item><item><title>filepath.Ext Notes</title><link>https://parsiya.net/blog/2018-11-10-filepath.ext-notes/</link><pubDate>Sat, 10 Nov 2018 00:59:58 -0500</pubDate><guid>https://parsiya.net/blog/2018-11-10-filepath.ext-notes/</guid><description>&lt;p>The &lt;a href="https://golang.org/pkg/path/filepath/" target="_blank" rel="noreferrer noopener">filepath&lt;/a> package has some functions for processing paths and filenames. I am using it extensively in a current project. You can do cool stuff with it, like &lt;a href="https://parsiya.net/blog/2018-10-06-gophercises-lessons-learned/#filepath-walk" title="filepath.Walk">traversing a path recursively with filepath.Walk&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://golang.org/pkg/path/filepath/#Ext" target="_blank" rel="noreferrer noopener">filepath.Ext&lt;/a> returns the extension of a filename (or path). It returns whatever is after the last dot. It has some gotchas that might have security implications.&lt;/p>
&lt;p>Code is at: &lt;a href="https://github.com/parsiya/Parsia-Code/tree/master/filepath-ext" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/filepath-ext&lt;/a>&lt;/p></description></item><item><title>Windows Filetime Timestamps and Byte Wrangling with Go</title><link>https://parsiya.net/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/</link><pubDate>Thu, 01 Nov 2018 08:05:47 -0400</pubDate><guid>https://parsiya.net/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/</guid><description>&lt;p>For a side project, I have to parse timestamps in a file. These timestamps are in the Windows Filetime format. This post documents what I have learned about them and how they can be converted to a Golang &lt;a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noreferrer noopener">time.Time&lt;/a> and then converted to any desirable format after that.&lt;/p>
&lt;p>We will start by looking at endian-ness and use a real-world example to practice our newly acquired knowledge.&lt;/p>
&lt;p>&lt;strong>TL;DR: To convert a Windows Filetime to Go's time.Time:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Read 8 bytes in LittleEndian from the file.&lt;/li>
&lt;li>Create a &lt;code>syscall.Filetime&lt;/code>.
&lt;ul>
&lt;li>Assign the first 4 bytes to &lt;code>LowDateTime&lt;/code> field and the other four to &lt;code>HighDateTime&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Convert the resulting Filetime to nanoseconds with &lt;a href="https://godoc.org/golang.org/x/sys/windows#Filetime.Nanoseconds" target="_blank" rel="noreferrer noopener">Filetime.Nanoseconds()&lt;/a>.&lt;/li>
&lt;li>Convert the resulting value to &lt;a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noreferrer noopener">time.Time&lt;/a>.&lt;/li>
&lt;/ol>
&lt;p>The code is at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blackfriday's Parser and Generating graphs with gographviz</title><link>https://parsiya.net/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/</link><pubDate>Sun, 28 Oct 2018 11:31:34 -0400</pubDate><guid>https://parsiya.net/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/</guid><description>&lt;p>I have been working on a personal automation project. In short, I write most of my notes in markdown so I wanted to grab them and store them in a specific format with annotations (e.g. everything under heading &lt;code>deployment notes&lt;/code> is labeled as such in the final data file). These are not high volume, large files. I have written them manually, I am talking about a 10-20 KB file (with most content being pasted code/request snippets). I am not looking for efficiency.&lt;/p>
&lt;p>&lt;a href="https://godoc.org/gopkg.in/russross/blackfriday.v2" target="_blank" rel="noreferrer noopener">Blackfriday&lt;/a> is the markdown parser for &lt;a href="https://github.com/gohugoio/hugo" target="_blank" rel="noreferrer noopener">Hugo&lt;/a>, so I was somewhat familiar with it. Since version 2, it has a markdown parser.&lt;/p>
&lt;p>In this post, I am going to describe what I learned during the process and how I leveraged Blackfriday's markdown parser in some hacky ways to get annotated data. To visualize the AST (Abstract Syntax Tree) generated by Blackfriday, I used &lt;a href="https://github.com/awalterschulze/gographviz" target="_blank" rel="noreferrer noopener">gographviz&lt;/a>.&lt;/p>
&lt;p>A simple package &lt;code>parse&lt;/code> and code can be found here:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Parsia-Code/tree/master/markdown-parsing" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/markdown-parsing&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Gophercises - Lessons Learned</title><link>https://parsiya.net/blog/2018-10-06-gophercises-lessons-learned/</link><pubDate>Sat, 06 Oct 2018 00:22:58 -0400</pubDate><guid>https://parsiya.net/blog/2018-10-06-gophercises-lessons-learned/</guid><description>&lt;p>I recently finished &lt;a href="https://gophercises.com" target="_blank" rel="noreferrer noopener">Gophercises&lt;/a>, a great set of Go practice lessons by &lt;a href="https://www.calhoun.io/" target="_blank" rel="noreferrer noopener">Jon Calhoun&lt;/a>. I think it took me around a month from start to finish with some stuff in the middle. Most were nice, some were tedious. For example, the last exercise was about &lt;a href="https://gophercises.com/exercises/pdf" target="_blank" rel="noreferrer noopener">PDF generation&lt;/a> and went to boring quickly.&lt;/p>
&lt;p>After every lesson, I wrote down &amp;quot;Lessons Learned&amp;quot; in the README. This page collects most of them. All code is here:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Parsia-Code/tree/master/gophercises" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/gophercises&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Learning Go-Fuzz 2: goexif2</title><link>https://parsiya.net/blog/2018-05-05-learning-go-fuzz-2-goexif2/</link><pubDate>Sat, 05 May 2018 18:01:09 -0400</pubDate><guid>https://parsiya.net/blog/2018-05-05-learning-go-fuzz-2-goexif2/</guid><description>&lt;p>Previously on &lt;code>Learning Go-Fuzz&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://parsiya.net/blog/2018-04-29-learning-go-fuzz-1-iprange/" title="Learning Go-Fuzz 1: iprange">&amp;quot;Learning Go-Fuzz 1: iprange&amp;quot;&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>This time I am looking at a different package. This is a package called &lt;code>goexif&lt;/code> at &lt;a href="https://github.com/rwcarlsen/goexif" target="_blank" rel="noreferrer noopener">https://github.com/rwcarlsen/goexif&lt;/a>. Being a file parser, it's a prime target for &lt;code>Go-Fuzz&lt;/code>. Unfortunately it has not been updated for a while. Instead, we will be looking at a fork at &lt;a href="https://github.com/xor-gate/goexif2" target="_blank" rel="noreferrer noopener">https://github.com/xor-gate/goexif2&lt;/a>.&lt;/p>
&lt;p>Code and fuzzing artifacts are at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Go-Security/tree/master/go-fuzz/goexif2" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/tree/master/go-fuzz/goexif2&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- Links in summary --></description></item><item><title>Learning Go-Fuzz 1: iprange</title><link>https://parsiya.net/blog/2018-04-29-learning-go-fuzz-1-iprange/</link><pubDate>Sun, 29 Apr 2018 19:25:10 -0400</pubDate><guid>https://parsiya.net/blog/2018-04-29-learning-go-fuzz-1-iprange/</guid><description>&lt;p>&lt;a href="https://github.com/dvyukov/go-fuzz" target="_blank" rel="noreferrer noopener">Go-Fuzz&lt;/a> is like AFL but for Go. If you have a Go package that parses some input, you might be able fuzz it with Go-Fuzz (terms and conditions apply). Not everything can be fuzzed very easily. For example Go-Fuzz does not like cycling imports, so if one of your sub-packages imports the main package then you are in trouble (I am looking at your &lt;a href="https://github.com/alecthomas/chroma" target="_blank" rel="noreferrer noopener">Chroma&lt;/a>).&lt;/p>
&lt;p>The rest of the article will show how to use Go-Fuzz to fuzz a Go library named &lt;code>iprange&lt;/code> at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/malfunkt/iprange" target="_blank" rel="noreferrer noopener">https://github.com/malfunkt/iprange&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Code and fuzzing artifacts are at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Go-Security/tree/master/go-fuzz/iprange" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/tree/master/go-fuzz/iprange&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- Summary Links --></description></item><item><title>Extracting PNG Chunks with Go</title><link>https://parsiya.net/blog/2018-02-25-extracting-png-chunks-with-go/</link><pubDate>Sun, 25 Feb 2018 18:27:49 -0500</pubDate><guid>https://parsiya.net/blog/2018-02-25-extracting-png-chunks-with-go/</guid><description>&lt;p>Yesterday I had to extract some data from hidden chunks in PNG files. I realized the PNG file format is blissfully simple.&lt;/p>
&lt;p>I wrote some quick code that parses a PNG file, extracts some information, identifies chunks and finally extracts chunk data. The code has minimal error handling (if chunks are not formatted properly). We also do not care about parsing &lt;code>PLTE&lt;/code> and &lt;code>tRNS&lt;/code> chunks although we will extract them.&lt;/p>
&lt;p>Code is at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Go-Security/blob/master/png-tests/png-chunk-extraction.go" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/blob/master/png-tests/png-chunk-extraction.go&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Decoding Large Base64 Files with Go</title><link>https://parsiya.net/blog/2018-01-19-decoding-large-base64-files-with-go/</link><pubDate>Fri, 19 Jan 2018 22:45:55 -0500</pubDate><guid>https://parsiya.net/blog/2018-01-19-decoding-large-base64-files-with-go/</guid><description>&lt;p>I am working on this challenge and it has a large base64 file. Each line has 2 characters and it has 150+ million lines.&lt;/p>
&lt;p>Luckily we can use the &lt;a href="https://golang.org/pkg/encoding/base64/#NewDecoder" target="_blank" rel="noreferrer noopener">Base64 stream decoder&lt;/a>. It reads from an &lt;code>io.Reader&lt;/code> and returns one that can be copied into an &lt;code>io.Writer&lt;/code>. It also takes care of the new lines.&lt;/p>
&lt;p>Sample code is at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Go-Security/blob/master/base64-stream-decoder/b64-stream-decoder.go" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/blob/master/base64-stream-decoder/b64-stream-decoder.go&lt;/a>.&lt;/li>
&lt;/ul></description></item><item><title>Simple SSH Harvester in Go</title><link>https://parsiya.net/blog/2017-12-29-simple-ssh-harvester-in-go/</link><pubDate>Fri, 29 Dec 2017 13:40:56 -0500</pubDate><guid>https://parsiya.net/blog/2017-12-29-simple-ssh-harvester-in-go/</guid><description>&lt;p>During my Go SSH adventures at &lt;a href="https://github.com/parsiya/Hacking-with-Go/blob/master/content/04.4.md" target="_blank" rel="noreferrer noopener">Hacking with Go&lt;/a> I wanted to write a simple SSH harvester. As usual, the tool turned out to be much larger than I thought.&lt;/p>
&lt;p>I realized I cannot find any examples of SSH certificate verification. There are a few examples for host keys here and there. Even the &lt;code>certs_test.go&lt;/code> file just checks the host name. There was a &lt;a href="https://github.com/golang/go/issues/23266" target="_blank" rel="noreferrer noopener">typo in an error message&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> in the &lt;code>crypto/ssh&lt;/code> package but I think because this is not very much used, had gone unreported.&lt;/p>
&lt;p>Here's my step by step guide to writing this tool by piggybacking on SSH host verification callbacks. Hopefully this will make it easier for the next person.&lt;/p>
&lt;p>You can find the code here:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/SSH-Scanner/blob/master/SSHHarvesterv1.go?ts=4" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/SSH-Scanner/blob/master/SSHHarvesterv1.go&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="tldr-verifying-ssh-servers">TL;DR: verifying SSH servers
&lt;a class="header-link" href="#tldr-verifying-ssh-servers">&lt;svg class="fill-current o-60 hover-accent-color-light" height="22px" viewBox="0 0 24 24" width="22px" xmlns="http://www.w3.org/2000/svg">&lt;path d="M0 0h24v24H0z" fill="none"/>&lt;path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>&lt;/svg>&lt;/a>
&lt;/h3>&lt;ol>
&lt;li>Create an instance of &lt;a href="https://godoc.org/golang.org/x/crypto/ssh#CertChecker" target="_blank" rel="noreferrer noopener">ssh.CertChecker&lt;/a>.&lt;/li>
&lt;li>Set callback functions for &lt;code>IsHostAuthority&lt;/code>, &lt;code>IsRevoked&lt;/code> and optionally &lt;code>HostKeyFallback&lt;/code>.
&lt;ul>
&lt;li>&lt;code>IsHostAuthority&lt;/code>'s callback should return &lt;code>true&lt;/code> for valid certificates.&lt;/li>
&lt;li>&lt;code>IsRevoked&lt;/code>'s callback should return &lt;code>false&lt;/code> for valid certificates.&lt;/li>
&lt;li>&lt;code>HostKeyFallback&lt;/code>'s callback should return &lt;code>nil&lt;/code> for valid certificates.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Create an instance of &lt;a href="https://godoc.org/golang.org/x/crypto/ssh#ClientConfig" target="_blank" rel="noreferrer noopener">ssh.ClientConfig&lt;/a>.&lt;/li>
&lt;li>Set &lt;code>HostKeyCallback&lt;/code> in &lt;code>ClientConfig&lt;/code> to &lt;code>&amp;amp;ssh.CertChecker.CheckHostKey&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://godoc.org/golang.org/x/crypto/ssh#CertChecker.CheckHostKey" target="_blank" rel="noreferrer noopener">CheckHostKey&lt;/a> will verify the certificate based on other callback functions.&lt;/li>
&lt;li>The certificate can be accessed in &lt;code>IsRevoked&lt;/code> callback function.&lt;/li>
&lt;/ol></description></item><item><title>Go and pcaps</title><link>https://parsiya.net/blog/2017-12-03-go-and-pcaps/</link><pubDate>Sun, 03 Dec 2017 18:40:26 -0500</pubDate><guid>https://parsiya.net/blog/2017-12-03-go-and-pcaps/</guid><description>&lt;p>I was trying to solve a challenge where the &amp;quot;hidden data&amp;quot; were in ICMP echo payloads. I decided to do it in Go but there were some hiccups on the way. Here are my notes in case (most likely) future me or someone else needs to do the same.&lt;/p>
&lt;p>Code is in my clone at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/parsiya/Go-Security/tree/master/pcap-tutorial" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Go-Security/tree/master/pcap-tutorial&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Go Notes</title><link>https://parsiya.net/go/</link><pubDate>Wed, 01 Jun 2016 20:35:00 -0400</pubDate><guid>https://parsiya.net/go/</guid><description>These notes have moved to https://parsiya.io/dev/go/.</description></item><item><title>Learning Go</title><link>https://parsiya.net/blog/2016-06-01-learning-go/</link><pubDate>Wed, 01 Jun 2016 20:35:00 -0400</pubDate><guid>https://parsiya.net/blog/2016-06-01-learning-go/</guid><description>&lt;p>I have decided to learn Go (or Golang). I went through the &lt;a href="https://tour.golang.org/" target="_blank" rel="noreferrer noopener">Tour of Go&lt;/a> and made some notes. Some of the items/code are directly copy pasted from there. The notes are just a cheatsheet to help me look things up quickly while learning. I will update that page as I learn more.&lt;/p>
&lt;p>You can see the notes at &lt;a href="https://parsiya.net/go/" title="Go Notes">https://parsiya.net/go/&lt;/a>.&lt;/p></description></item></channel></rss>